package domain

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/loms/internal/domain.OrdersRepository -o ./zzz_carts_repo_minimock_test.go -n OrdersRepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// OrdersRepositoryMock implements OrdersRepository
type OrdersRepositoryMock struct {
	t minimock.Tester

	funcCreateOrder          func(ctx context.Context, order *Order) (i1 int64, err error)
	inspectFuncCreateOrder   func(ctx context.Context, order *Order)
	afterCreateOrderCounter  uint64
	beforeCreateOrderCounter uint64
	CreateOrderMock          mOrdersRepositoryMockCreateOrder

	funcGetOrder          func(ctx context.Context, id int64) (op1 *Order, err error)
	inspectFuncGetOrder   func(ctx context.Context, id int64)
	afterGetOrderCounter  uint64
	beforeGetOrderCounter uint64
	GetOrderMock          mOrdersRepositoryMockGetOrder

	funcRemoveSoldItems          func(ctx context.Context, orderID int64) (err error)
	inspectFuncRemoveSoldItems   func(ctx context.Context, orderID int64)
	afterRemoveSoldItemsCounter  uint64
	beforeRemoveSoldItemsCounter uint64
	RemoveSoldItemsMock          mOrdersRepositoryMockRemoveSoldItems

	funcReserveStock          func(ctx context.Context, orderID int64, item ReservedItem) (err error)
	inspectFuncReserveStock   func(ctx context.Context, orderID int64, item ReservedItem)
	afterReserveStockCounter  uint64
	beforeReserveStockCounter uint64
	ReserveStockMock          mOrdersRepositoryMockReserveStock

	funcStocks          func(ctx context.Context, sku uint32) (sa1 []Stock, err error)
	inspectFuncStocks   func(ctx context.Context, sku uint32)
	afterStocksCounter  uint64
	beforeStocksCounter uint64
	StocksMock          mOrdersRepositoryMockStocks

	funcUnReserveItems          func(ctx context.Context, orderID int64) (err error)
	inspectFuncUnReserveItems   func(ctx context.Context, orderID int64)
	afterUnReserveItemsCounter  uint64
	beforeUnReserveItemsCounter uint64
	UnReserveItemsMock          mOrdersRepositoryMockUnReserveItems

	funcUpdateOrderStatus          func(ctx context.Context, id int64, status string, statusBefore string) (err error)
	inspectFuncUpdateOrderStatus   func(ctx context.Context, id int64, status string, statusBefore string)
	afterUpdateOrderStatusCounter  uint64
	beforeUpdateOrderStatusCounter uint64
	UpdateOrderStatusMock          mOrdersRepositoryMockUpdateOrderStatus
}

// NewOrdersRepositoryMock returns a mock for OrdersRepository
func NewOrdersRepositoryMock(t minimock.Tester) *OrdersRepositoryMock {
	m := &OrdersRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateOrderMock = mOrdersRepositoryMockCreateOrder{mock: m}
	m.CreateOrderMock.callArgs = []*OrdersRepositoryMockCreateOrderParams{}

	m.GetOrderMock = mOrdersRepositoryMockGetOrder{mock: m}
	m.GetOrderMock.callArgs = []*OrdersRepositoryMockGetOrderParams{}

	m.RemoveSoldItemsMock = mOrdersRepositoryMockRemoveSoldItems{mock: m}
	m.RemoveSoldItemsMock.callArgs = []*OrdersRepositoryMockRemoveSoldItemsParams{}

	m.ReserveStockMock = mOrdersRepositoryMockReserveStock{mock: m}
	m.ReserveStockMock.callArgs = []*OrdersRepositoryMockReserveStockParams{}

	m.StocksMock = mOrdersRepositoryMockStocks{mock: m}
	m.StocksMock.callArgs = []*OrdersRepositoryMockStocksParams{}

	m.UnReserveItemsMock = mOrdersRepositoryMockUnReserveItems{mock: m}
	m.UnReserveItemsMock.callArgs = []*OrdersRepositoryMockUnReserveItemsParams{}

	m.UpdateOrderStatusMock = mOrdersRepositoryMockUpdateOrderStatus{mock: m}
	m.UpdateOrderStatusMock.callArgs = []*OrdersRepositoryMockUpdateOrderStatusParams{}

	return m
}

type mOrdersRepositoryMockCreateOrder struct {
	mock               *OrdersRepositoryMock
	defaultExpectation *OrdersRepositoryMockCreateOrderExpectation
	expectations       []*OrdersRepositoryMockCreateOrderExpectation

	callArgs []*OrdersRepositoryMockCreateOrderParams
	mutex    sync.RWMutex
}

// OrdersRepositoryMockCreateOrderExpectation specifies expectation struct of the OrdersRepository.CreateOrder
type OrdersRepositoryMockCreateOrderExpectation struct {
	mock    *OrdersRepositoryMock
	params  *OrdersRepositoryMockCreateOrderParams
	results *OrdersRepositoryMockCreateOrderResults
	Counter uint64
}

// OrdersRepositoryMockCreateOrderParams contains parameters of the OrdersRepository.CreateOrder
type OrdersRepositoryMockCreateOrderParams struct {
	ctx   context.Context
	order *Order
}

// OrdersRepositoryMockCreateOrderResults contains results of the OrdersRepository.CreateOrder
type OrdersRepositoryMockCreateOrderResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for OrdersRepository.CreateOrder
func (mmCreateOrder *mOrdersRepositoryMockCreateOrder) Expect(ctx context.Context, order *Order) *mOrdersRepositoryMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("OrdersRepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &OrdersRepositoryMockCreateOrderExpectation{}
	}

	mmCreateOrder.defaultExpectation.params = &OrdersRepositoryMockCreateOrderParams{ctx, order}
	for _, e := range mmCreateOrder.expectations {
		if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) {
			mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
		}
	}

	return mmCreateOrder
}

// Inspect accepts an inspector function that has same arguments as the OrdersRepository.CreateOrder
func (mmCreateOrder *mOrdersRepositoryMockCreateOrder) Inspect(f func(ctx context.Context, order *Order)) *mOrdersRepositoryMockCreateOrder {
	if mmCreateOrder.mock.inspectFuncCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("Inspect function is already set for OrdersRepositoryMock.CreateOrder")
	}

	mmCreateOrder.mock.inspectFuncCreateOrder = f

	return mmCreateOrder
}

// Return sets up results that will be returned by OrdersRepository.CreateOrder
func (mmCreateOrder *mOrdersRepositoryMockCreateOrder) Return(i1 int64, err error) *OrdersRepositoryMock {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("OrdersRepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &OrdersRepositoryMockCreateOrderExpectation{mock: mmCreateOrder.mock}
	}
	mmCreateOrder.defaultExpectation.results = &OrdersRepositoryMockCreateOrderResults{i1, err}
	return mmCreateOrder.mock
}

// Set uses given function f to mock the OrdersRepository.CreateOrder method
func (mmCreateOrder *mOrdersRepositoryMockCreateOrder) Set(f func(ctx context.Context, order *Order) (i1 int64, err error)) *OrdersRepositoryMock {
	if mmCreateOrder.defaultExpectation != nil {
		mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the OrdersRepository.CreateOrder method")
	}

	if len(mmCreateOrder.expectations) > 0 {
		mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the OrdersRepository.CreateOrder method")
	}

	mmCreateOrder.mock.funcCreateOrder = f
	return mmCreateOrder.mock
}

// When sets expectation for the OrdersRepository.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mOrdersRepositoryMockCreateOrder) When(ctx context.Context, order *Order) *OrdersRepositoryMockCreateOrderExpectation {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("OrdersRepositoryMock.CreateOrder mock is already set by Set")
	}

	expectation := &OrdersRepositoryMockCreateOrderExpectation{
		mock:   mmCreateOrder.mock,
		params: &OrdersRepositoryMockCreateOrderParams{ctx, order},
	}
	mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
	return expectation
}

// Then sets up OrdersRepository.CreateOrder return parameters for the expectation previously defined by the When method
func (e *OrdersRepositoryMockCreateOrderExpectation) Then(i1 int64, err error) *OrdersRepositoryMock {
	e.results = &OrdersRepositoryMockCreateOrderResults{i1, err}
	return e.mock
}

// CreateOrder implements OrdersRepository
func (mmCreateOrder *OrdersRepositoryMock) CreateOrder(ctx context.Context, order *Order) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateOrder.beforeCreateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrder.afterCreateOrderCounter, 1)

	if mmCreateOrder.inspectFuncCreateOrder != nil {
		mmCreateOrder.inspectFuncCreateOrder(ctx, order)
	}

	mm_params := &OrdersRepositoryMockCreateOrderParams{ctx, order}

	// Record call args
	mmCreateOrder.CreateOrderMock.mutex.Lock()
	mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, mm_params)
	mmCreateOrder.CreateOrderMock.mutex.Unlock()

	for _, e := range mmCreateOrder.CreateOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateOrder.CreateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
		mm_got := OrdersRepositoryMockCreateOrderParams{ctx, order}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrder.t.Errorf("OrdersRepositoryMock.CreateOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrder.t.Fatal("No results are set for the OrdersRepositoryMock.CreateOrder")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateOrder.funcCreateOrder != nil {
		return mmCreateOrder.funcCreateOrder(ctx, order)
	}
	mmCreateOrder.t.Fatalf("Unexpected call to OrdersRepositoryMock.CreateOrder. %v %v", ctx, order)
	return
}

// CreateOrderAfterCounter returns a count of finished OrdersRepositoryMock.CreateOrder invocations
func (mmCreateOrder *OrdersRepositoryMock) CreateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.afterCreateOrderCounter)
}

// CreateOrderBeforeCounter returns a count of OrdersRepositoryMock.CreateOrder invocations
func (mmCreateOrder *OrdersRepositoryMock) CreateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.beforeCreateOrderCounter)
}

// Calls returns a list of arguments used in each call to OrdersRepositoryMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mOrdersRepositoryMockCreateOrder) Calls() []*OrdersRepositoryMockCreateOrderParams {
	mmCreateOrder.mutex.RLock()

	argCopy := make([]*OrdersRepositoryMockCreateOrderParams, len(mmCreateOrder.callArgs))
	copy(argCopy, mmCreateOrder.callArgs)

	mmCreateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *OrdersRepositoryMock) MinimockCreateOrderDone() bool {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *OrdersRepositoryMock) MinimockCreateOrderInspect() {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersRepositoryMock.CreateOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		if m.CreateOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrdersRepositoryMock.CreateOrder")
		} else {
			m.t.Errorf("Expected call to OrdersRepositoryMock.CreateOrder with params: %#v", *m.CreateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		m.t.Error("Expected call to OrdersRepositoryMock.CreateOrder")
	}
}

type mOrdersRepositoryMockGetOrder struct {
	mock               *OrdersRepositoryMock
	defaultExpectation *OrdersRepositoryMockGetOrderExpectation
	expectations       []*OrdersRepositoryMockGetOrderExpectation

	callArgs []*OrdersRepositoryMockGetOrderParams
	mutex    sync.RWMutex
}

// OrdersRepositoryMockGetOrderExpectation specifies expectation struct of the OrdersRepository.GetOrder
type OrdersRepositoryMockGetOrderExpectation struct {
	mock    *OrdersRepositoryMock
	params  *OrdersRepositoryMockGetOrderParams
	results *OrdersRepositoryMockGetOrderResults
	Counter uint64
}

// OrdersRepositoryMockGetOrderParams contains parameters of the OrdersRepository.GetOrder
type OrdersRepositoryMockGetOrderParams struct {
	ctx context.Context
	id  int64
}

// OrdersRepositoryMockGetOrderResults contains results of the OrdersRepository.GetOrder
type OrdersRepositoryMockGetOrderResults struct {
	op1 *Order
	err error
}

// Expect sets up expected params for OrdersRepository.GetOrder
func (mmGetOrder *mOrdersRepositoryMockGetOrder) Expect(ctx context.Context, id int64) *mOrdersRepositoryMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("OrdersRepositoryMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &OrdersRepositoryMockGetOrderExpectation{}
	}

	mmGetOrder.defaultExpectation.params = &OrdersRepositoryMockGetOrderParams{ctx, id}
	for _, e := range mmGetOrder.expectations {
		if minimock.Equal(e.params, mmGetOrder.defaultExpectation.params) {
			mmGetOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrder.defaultExpectation.params)
		}
	}

	return mmGetOrder
}

// Inspect accepts an inspector function that has same arguments as the OrdersRepository.GetOrder
func (mmGetOrder *mOrdersRepositoryMockGetOrder) Inspect(f func(ctx context.Context, id int64)) *mOrdersRepositoryMockGetOrder {
	if mmGetOrder.mock.inspectFuncGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("Inspect function is already set for OrdersRepositoryMock.GetOrder")
	}

	mmGetOrder.mock.inspectFuncGetOrder = f

	return mmGetOrder
}

// Return sets up results that will be returned by OrdersRepository.GetOrder
func (mmGetOrder *mOrdersRepositoryMockGetOrder) Return(op1 *Order, err error) *OrdersRepositoryMock {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("OrdersRepositoryMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &OrdersRepositoryMockGetOrderExpectation{mock: mmGetOrder.mock}
	}
	mmGetOrder.defaultExpectation.results = &OrdersRepositoryMockGetOrderResults{op1, err}
	return mmGetOrder.mock
}

// Set uses given function f to mock the OrdersRepository.GetOrder method
func (mmGetOrder *mOrdersRepositoryMockGetOrder) Set(f func(ctx context.Context, id int64) (op1 *Order, err error)) *OrdersRepositoryMock {
	if mmGetOrder.defaultExpectation != nil {
		mmGetOrder.mock.t.Fatalf("Default expectation is already set for the OrdersRepository.GetOrder method")
	}

	if len(mmGetOrder.expectations) > 0 {
		mmGetOrder.mock.t.Fatalf("Some expectations are already set for the OrdersRepository.GetOrder method")
	}

	mmGetOrder.mock.funcGetOrder = f
	return mmGetOrder.mock
}

// When sets expectation for the OrdersRepository.GetOrder which will trigger the result defined by the following
// Then helper
func (mmGetOrder *mOrdersRepositoryMockGetOrder) When(ctx context.Context, id int64) *OrdersRepositoryMockGetOrderExpectation {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("OrdersRepositoryMock.GetOrder mock is already set by Set")
	}

	expectation := &OrdersRepositoryMockGetOrderExpectation{
		mock:   mmGetOrder.mock,
		params: &OrdersRepositoryMockGetOrderParams{ctx, id},
	}
	mmGetOrder.expectations = append(mmGetOrder.expectations, expectation)
	return expectation
}

// Then sets up OrdersRepository.GetOrder return parameters for the expectation previously defined by the When method
func (e *OrdersRepositoryMockGetOrderExpectation) Then(op1 *Order, err error) *OrdersRepositoryMock {
	e.results = &OrdersRepositoryMockGetOrderResults{op1, err}
	return e.mock
}

// GetOrder implements OrdersRepository
func (mmGetOrder *OrdersRepositoryMock) GetOrder(ctx context.Context, id int64) (op1 *Order, err error) {
	mm_atomic.AddUint64(&mmGetOrder.beforeGetOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrder.afterGetOrderCounter, 1)

	if mmGetOrder.inspectFuncGetOrder != nil {
		mmGetOrder.inspectFuncGetOrder(ctx, id)
	}

	mm_params := &OrdersRepositoryMockGetOrderParams{ctx, id}

	// Record call args
	mmGetOrder.GetOrderMock.mutex.Lock()
	mmGetOrder.GetOrderMock.callArgs = append(mmGetOrder.GetOrderMock.callArgs, mm_params)
	mmGetOrder.GetOrderMock.mutex.Unlock()

	for _, e := range mmGetOrder.GetOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetOrder.GetOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrder.GetOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrder.GetOrderMock.defaultExpectation.params
		mm_got := OrdersRepositoryMockGetOrderParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrder.t.Errorf("OrdersRepositoryMock.GetOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrder.GetOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrder.t.Fatal("No results are set for the OrdersRepositoryMock.GetOrder")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetOrder.funcGetOrder != nil {
		return mmGetOrder.funcGetOrder(ctx, id)
	}
	mmGetOrder.t.Fatalf("Unexpected call to OrdersRepositoryMock.GetOrder. %v %v", ctx, id)
	return
}

// GetOrderAfterCounter returns a count of finished OrdersRepositoryMock.GetOrder invocations
func (mmGetOrder *OrdersRepositoryMock) GetOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.afterGetOrderCounter)
}

// GetOrderBeforeCounter returns a count of OrdersRepositoryMock.GetOrder invocations
func (mmGetOrder *OrdersRepositoryMock) GetOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.beforeGetOrderCounter)
}

// Calls returns a list of arguments used in each call to OrdersRepositoryMock.GetOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrder *mOrdersRepositoryMockGetOrder) Calls() []*OrdersRepositoryMockGetOrderParams {
	mmGetOrder.mutex.RLock()

	argCopy := make([]*OrdersRepositoryMockGetOrderParams, len(mmGetOrder.callArgs))
	copy(argCopy, mmGetOrder.callArgs)

	mmGetOrder.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderDone returns true if the count of the GetOrder invocations corresponds
// the number of defined expectations
func (m *OrdersRepositoryMock) MinimockGetOrderDone() bool {
	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrder != nil && mm_atomic.LoadUint64(&m.afterGetOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOrderInspect logs each unmet expectation
func (m *OrdersRepositoryMock) MinimockGetOrderInspect() {
	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersRepositoryMock.GetOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderCounter) < 1 {
		if m.GetOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrdersRepositoryMock.GetOrder")
		} else {
			m.t.Errorf("Expected call to OrdersRepositoryMock.GetOrder with params: %#v", *m.GetOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrder != nil && mm_atomic.LoadUint64(&m.afterGetOrderCounter) < 1 {
		m.t.Error("Expected call to OrdersRepositoryMock.GetOrder")
	}
}

type mOrdersRepositoryMockRemoveSoldItems struct {
	mock               *OrdersRepositoryMock
	defaultExpectation *OrdersRepositoryMockRemoveSoldItemsExpectation
	expectations       []*OrdersRepositoryMockRemoveSoldItemsExpectation

	callArgs []*OrdersRepositoryMockRemoveSoldItemsParams
	mutex    sync.RWMutex
}

// OrdersRepositoryMockRemoveSoldItemsExpectation specifies expectation struct of the OrdersRepository.RemoveSoldItems
type OrdersRepositoryMockRemoveSoldItemsExpectation struct {
	mock    *OrdersRepositoryMock
	params  *OrdersRepositoryMockRemoveSoldItemsParams
	results *OrdersRepositoryMockRemoveSoldItemsResults
	Counter uint64
}

// OrdersRepositoryMockRemoveSoldItemsParams contains parameters of the OrdersRepository.RemoveSoldItems
type OrdersRepositoryMockRemoveSoldItemsParams struct {
	ctx     context.Context
	orderID int64
}

// OrdersRepositoryMockRemoveSoldItemsResults contains results of the OrdersRepository.RemoveSoldItems
type OrdersRepositoryMockRemoveSoldItemsResults struct {
	err error
}

// Expect sets up expected params for OrdersRepository.RemoveSoldItems
func (mmRemoveSoldItems *mOrdersRepositoryMockRemoveSoldItems) Expect(ctx context.Context, orderID int64) *mOrdersRepositoryMockRemoveSoldItems {
	if mmRemoveSoldItems.mock.funcRemoveSoldItems != nil {
		mmRemoveSoldItems.mock.t.Fatalf("OrdersRepositoryMock.RemoveSoldItems mock is already set by Set")
	}

	if mmRemoveSoldItems.defaultExpectation == nil {
		mmRemoveSoldItems.defaultExpectation = &OrdersRepositoryMockRemoveSoldItemsExpectation{}
	}

	mmRemoveSoldItems.defaultExpectation.params = &OrdersRepositoryMockRemoveSoldItemsParams{ctx, orderID}
	for _, e := range mmRemoveSoldItems.expectations {
		if minimock.Equal(e.params, mmRemoveSoldItems.defaultExpectation.params) {
			mmRemoveSoldItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveSoldItems.defaultExpectation.params)
		}
	}

	return mmRemoveSoldItems
}

// Inspect accepts an inspector function that has same arguments as the OrdersRepository.RemoveSoldItems
func (mmRemoveSoldItems *mOrdersRepositoryMockRemoveSoldItems) Inspect(f func(ctx context.Context, orderID int64)) *mOrdersRepositoryMockRemoveSoldItems {
	if mmRemoveSoldItems.mock.inspectFuncRemoveSoldItems != nil {
		mmRemoveSoldItems.mock.t.Fatalf("Inspect function is already set for OrdersRepositoryMock.RemoveSoldItems")
	}

	mmRemoveSoldItems.mock.inspectFuncRemoveSoldItems = f

	return mmRemoveSoldItems
}

// Return sets up results that will be returned by OrdersRepository.RemoveSoldItems
func (mmRemoveSoldItems *mOrdersRepositoryMockRemoveSoldItems) Return(err error) *OrdersRepositoryMock {
	if mmRemoveSoldItems.mock.funcRemoveSoldItems != nil {
		mmRemoveSoldItems.mock.t.Fatalf("OrdersRepositoryMock.RemoveSoldItems mock is already set by Set")
	}

	if mmRemoveSoldItems.defaultExpectation == nil {
		mmRemoveSoldItems.defaultExpectation = &OrdersRepositoryMockRemoveSoldItemsExpectation{mock: mmRemoveSoldItems.mock}
	}
	mmRemoveSoldItems.defaultExpectation.results = &OrdersRepositoryMockRemoveSoldItemsResults{err}
	return mmRemoveSoldItems.mock
}

// Set uses given function f to mock the OrdersRepository.RemoveSoldItems method
func (mmRemoveSoldItems *mOrdersRepositoryMockRemoveSoldItems) Set(f func(ctx context.Context, orderID int64) (err error)) *OrdersRepositoryMock {
	if mmRemoveSoldItems.defaultExpectation != nil {
		mmRemoveSoldItems.mock.t.Fatalf("Default expectation is already set for the OrdersRepository.RemoveSoldItems method")
	}

	if len(mmRemoveSoldItems.expectations) > 0 {
		mmRemoveSoldItems.mock.t.Fatalf("Some expectations are already set for the OrdersRepository.RemoveSoldItems method")
	}

	mmRemoveSoldItems.mock.funcRemoveSoldItems = f
	return mmRemoveSoldItems.mock
}

// When sets expectation for the OrdersRepository.RemoveSoldItems which will trigger the result defined by the following
// Then helper
func (mmRemoveSoldItems *mOrdersRepositoryMockRemoveSoldItems) When(ctx context.Context, orderID int64) *OrdersRepositoryMockRemoveSoldItemsExpectation {
	if mmRemoveSoldItems.mock.funcRemoveSoldItems != nil {
		mmRemoveSoldItems.mock.t.Fatalf("OrdersRepositoryMock.RemoveSoldItems mock is already set by Set")
	}

	expectation := &OrdersRepositoryMockRemoveSoldItemsExpectation{
		mock:   mmRemoveSoldItems.mock,
		params: &OrdersRepositoryMockRemoveSoldItemsParams{ctx, orderID},
	}
	mmRemoveSoldItems.expectations = append(mmRemoveSoldItems.expectations, expectation)
	return expectation
}

// Then sets up OrdersRepository.RemoveSoldItems return parameters for the expectation previously defined by the When method
func (e *OrdersRepositoryMockRemoveSoldItemsExpectation) Then(err error) *OrdersRepositoryMock {
	e.results = &OrdersRepositoryMockRemoveSoldItemsResults{err}
	return e.mock
}

// RemoveSoldItems implements OrdersRepository
func (mmRemoveSoldItems *OrdersRepositoryMock) RemoveSoldItems(ctx context.Context, orderID int64) (err error) {
	mm_atomic.AddUint64(&mmRemoveSoldItems.beforeRemoveSoldItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveSoldItems.afterRemoveSoldItemsCounter, 1)

	if mmRemoveSoldItems.inspectFuncRemoveSoldItems != nil {
		mmRemoveSoldItems.inspectFuncRemoveSoldItems(ctx, orderID)
	}

	mm_params := &OrdersRepositoryMockRemoveSoldItemsParams{ctx, orderID}

	// Record call args
	mmRemoveSoldItems.RemoveSoldItemsMock.mutex.Lock()
	mmRemoveSoldItems.RemoveSoldItemsMock.callArgs = append(mmRemoveSoldItems.RemoveSoldItemsMock.callArgs, mm_params)
	mmRemoveSoldItems.RemoveSoldItemsMock.mutex.Unlock()

	for _, e := range mmRemoveSoldItems.RemoveSoldItemsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveSoldItems.RemoveSoldItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveSoldItems.RemoveSoldItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveSoldItems.RemoveSoldItemsMock.defaultExpectation.params
		mm_got := OrdersRepositoryMockRemoveSoldItemsParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveSoldItems.t.Errorf("OrdersRepositoryMock.RemoveSoldItems got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveSoldItems.RemoveSoldItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveSoldItems.t.Fatal("No results are set for the OrdersRepositoryMock.RemoveSoldItems")
		}
		return (*mm_results).err
	}
	if mmRemoveSoldItems.funcRemoveSoldItems != nil {
		return mmRemoveSoldItems.funcRemoveSoldItems(ctx, orderID)
	}
	mmRemoveSoldItems.t.Fatalf("Unexpected call to OrdersRepositoryMock.RemoveSoldItems. %v %v", ctx, orderID)
	return
}

// RemoveSoldItemsAfterCounter returns a count of finished OrdersRepositoryMock.RemoveSoldItems invocations
func (mmRemoveSoldItems *OrdersRepositoryMock) RemoveSoldItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveSoldItems.afterRemoveSoldItemsCounter)
}

// RemoveSoldItemsBeforeCounter returns a count of OrdersRepositoryMock.RemoveSoldItems invocations
func (mmRemoveSoldItems *OrdersRepositoryMock) RemoveSoldItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveSoldItems.beforeRemoveSoldItemsCounter)
}

// Calls returns a list of arguments used in each call to OrdersRepositoryMock.RemoveSoldItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveSoldItems *mOrdersRepositoryMockRemoveSoldItems) Calls() []*OrdersRepositoryMockRemoveSoldItemsParams {
	mmRemoveSoldItems.mutex.RLock()

	argCopy := make([]*OrdersRepositoryMockRemoveSoldItemsParams, len(mmRemoveSoldItems.callArgs))
	copy(argCopy, mmRemoveSoldItems.callArgs)

	mmRemoveSoldItems.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveSoldItemsDone returns true if the count of the RemoveSoldItems invocations corresponds
// the number of defined expectations
func (m *OrdersRepositoryMock) MinimockRemoveSoldItemsDone() bool {
	for _, e := range m.RemoveSoldItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveSoldItemsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveSoldItemsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveSoldItems != nil && mm_atomic.LoadUint64(&m.afterRemoveSoldItemsCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoveSoldItemsInspect logs each unmet expectation
func (m *OrdersRepositoryMock) MinimockRemoveSoldItemsInspect() {
	for _, e := range m.RemoveSoldItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersRepositoryMock.RemoveSoldItems with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveSoldItemsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveSoldItemsCounter) < 1 {
		if m.RemoveSoldItemsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrdersRepositoryMock.RemoveSoldItems")
		} else {
			m.t.Errorf("Expected call to OrdersRepositoryMock.RemoveSoldItems with params: %#v", *m.RemoveSoldItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveSoldItems != nil && mm_atomic.LoadUint64(&m.afterRemoveSoldItemsCounter) < 1 {
		m.t.Error("Expected call to OrdersRepositoryMock.RemoveSoldItems")
	}
}

type mOrdersRepositoryMockReserveStock struct {
	mock               *OrdersRepositoryMock
	defaultExpectation *OrdersRepositoryMockReserveStockExpectation
	expectations       []*OrdersRepositoryMockReserveStockExpectation

	callArgs []*OrdersRepositoryMockReserveStockParams
	mutex    sync.RWMutex
}

// OrdersRepositoryMockReserveStockExpectation specifies expectation struct of the OrdersRepository.ReserveStock
type OrdersRepositoryMockReserveStockExpectation struct {
	mock    *OrdersRepositoryMock
	params  *OrdersRepositoryMockReserveStockParams
	results *OrdersRepositoryMockReserveStockResults
	Counter uint64
}

// OrdersRepositoryMockReserveStockParams contains parameters of the OrdersRepository.ReserveStock
type OrdersRepositoryMockReserveStockParams struct {
	ctx     context.Context
	orderID int64
	item    ReservedItem
}

// OrdersRepositoryMockReserveStockResults contains results of the OrdersRepository.ReserveStock
type OrdersRepositoryMockReserveStockResults struct {
	err error
}

// Expect sets up expected params for OrdersRepository.ReserveStock
func (mmReserveStock *mOrdersRepositoryMockReserveStock) Expect(ctx context.Context, orderID int64, item ReservedItem) *mOrdersRepositoryMockReserveStock {
	if mmReserveStock.mock.funcReserveStock != nil {
		mmReserveStock.mock.t.Fatalf("OrdersRepositoryMock.ReserveStock mock is already set by Set")
	}

	if mmReserveStock.defaultExpectation == nil {
		mmReserveStock.defaultExpectation = &OrdersRepositoryMockReserveStockExpectation{}
	}

	mmReserveStock.defaultExpectation.params = &OrdersRepositoryMockReserveStockParams{ctx, orderID, item}
	for _, e := range mmReserveStock.expectations {
		if minimock.Equal(e.params, mmReserveStock.defaultExpectation.params) {
			mmReserveStock.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveStock.defaultExpectation.params)
		}
	}

	return mmReserveStock
}

// Inspect accepts an inspector function that has same arguments as the OrdersRepository.ReserveStock
func (mmReserveStock *mOrdersRepositoryMockReserveStock) Inspect(f func(ctx context.Context, orderID int64, item ReservedItem)) *mOrdersRepositoryMockReserveStock {
	if mmReserveStock.mock.inspectFuncReserveStock != nil {
		mmReserveStock.mock.t.Fatalf("Inspect function is already set for OrdersRepositoryMock.ReserveStock")
	}

	mmReserveStock.mock.inspectFuncReserveStock = f

	return mmReserveStock
}

// Return sets up results that will be returned by OrdersRepository.ReserveStock
func (mmReserveStock *mOrdersRepositoryMockReserveStock) Return(err error) *OrdersRepositoryMock {
	if mmReserveStock.mock.funcReserveStock != nil {
		mmReserveStock.mock.t.Fatalf("OrdersRepositoryMock.ReserveStock mock is already set by Set")
	}

	if mmReserveStock.defaultExpectation == nil {
		mmReserveStock.defaultExpectation = &OrdersRepositoryMockReserveStockExpectation{mock: mmReserveStock.mock}
	}
	mmReserveStock.defaultExpectation.results = &OrdersRepositoryMockReserveStockResults{err}
	return mmReserveStock.mock
}

// Set uses given function f to mock the OrdersRepository.ReserveStock method
func (mmReserveStock *mOrdersRepositoryMockReserveStock) Set(f func(ctx context.Context, orderID int64, item ReservedItem) (err error)) *OrdersRepositoryMock {
	if mmReserveStock.defaultExpectation != nil {
		mmReserveStock.mock.t.Fatalf("Default expectation is already set for the OrdersRepository.ReserveStock method")
	}

	if len(mmReserveStock.expectations) > 0 {
		mmReserveStock.mock.t.Fatalf("Some expectations are already set for the OrdersRepository.ReserveStock method")
	}

	mmReserveStock.mock.funcReserveStock = f
	return mmReserveStock.mock
}

// When sets expectation for the OrdersRepository.ReserveStock which will trigger the result defined by the following
// Then helper
func (mmReserveStock *mOrdersRepositoryMockReserveStock) When(ctx context.Context, orderID int64, item ReservedItem) *OrdersRepositoryMockReserveStockExpectation {
	if mmReserveStock.mock.funcReserveStock != nil {
		mmReserveStock.mock.t.Fatalf("OrdersRepositoryMock.ReserveStock mock is already set by Set")
	}

	expectation := &OrdersRepositoryMockReserveStockExpectation{
		mock:   mmReserveStock.mock,
		params: &OrdersRepositoryMockReserveStockParams{ctx, orderID, item},
	}
	mmReserveStock.expectations = append(mmReserveStock.expectations, expectation)
	return expectation
}

// Then sets up OrdersRepository.ReserveStock return parameters for the expectation previously defined by the When method
func (e *OrdersRepositoryMockReserveStockExpectation) Then(err error) *OrdersRepositoryMock {
	e.results = &OrdersRepositoryMockReserveStockResults{err}
	return e.mock
}

// ReserveStock implements OrdersRepository
func (mmReserveStock *OrdersRepositoryMock) ReserveStock(ctx context.Context, orderID int64, item ReservedItem) (err error) {
	mm_atomic.AddUint64(&mmReserveStock.beforeReserveStockCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveStock.afterReserveStockCounter, 1)

	if mmReserveStock.inspectFuncReserveStock != nil {
		mmReserveStock.inspectFuncReserveStock(ctx, orderID, item)
	}

	mm_params := &OrdersRepositoryMockReserveStockParams{ctx, orderID, item}

	// Record call args
	mmReserveStock.ReserveStockMock.mutex.Lock()
	mmReserveStock.ReserveStockMock.callArgs = append(mmReserveStock.ReserveStockMock.callArgs, mm_params)
	mmReserveStock.ReserveStockMock.mutex.Unlock()

	for _, e := range mmReserveStock.ReserveStockMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveStock.ReserveStockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveStock.ReserveStockMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveStock.ReserveStockMock.defaultExpectation.params
		mm_got := OrdersRepositoryMockReserveStockParams{ctx, orderID, item}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveStock.t.Errorf("OrdersRepositoryMock.ReserveStock got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveStock.ReserveStockMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveStock.t.Fatal("No results are set for the OrdersRepositoryMock.ReserveStock")
		}
		return (*mm_results).err
	}
	if mmReserveStock.funcReserveStock != nil {
		return mmReserveStock.funcReserveStock(ctx, orderID, item)
	}
	mmReserveStock.t.Fatalf("Unexpected call to OrdersRepositoryMock.ReserveStock. %v %v %v", ctx, orderID, item)
	return
}

// ReserveStockAfterCounter returns a count of finished OrdersRepositoryMock.ReserveStock invocations
func (mmReserveStock *OrdersRepositoryMock) ReserveStockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveStock.afterReserveStockCounter)
}

// ReserveStockBeforeCounter returns a count of OrdersRepositoryMock.ReserveStock invocations
func (mmReserveStock *OrdersRepositoryMock) ReserveStockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveStock.beforeReserveStockCounter)
}

// Calls returns a list of arguments used in each call to OrdersRepositoryMock.ReserveStock.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveStock *mOrdersRepositoryMockReserveStock) Calls() []*OrdersRepositoryMockReserveStockParams {
	mmReserveStock.mutex.RLock()

	argCopy := make([]*OrdersRepositoryMockReserveStockParams, len(mmReserveStock.callArgs))
	copy(argCopy, mmReserveStock.callArgs)

	mmReserveStock.mutex.RUnlock()

	return argCopy
}

// MinimockReserveStockDone returns true if the count of the ReserveStock invocations corresponds
// the number of defined expectations
func (m *OrdersRepositoryMock) MinimockReserveStockDone() bool {
	for _, e := range m.ReserveStockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveStockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReserveStockCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveStock != nil && mm_atomic.LoadUint64(&m.afterReserveStockCounter) < 1 {
		return false
	}
	return true
}

// MinimockReserveStockInspect logs each unmet expectation
func (m *OrdersRepositoryMock) MinimockReserveStockInspect() {
	for _, e := range m.ReserveStockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersRepositoryMock.ReserveStock with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveStockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReserveStockCounter) < 1 {
		if m.ReserveStockMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrdersRepositoryMock.ReserveStock")
		} else {
			m.t.Errorf("Expected call to OrdersRepositoryMock.ReserveStock with params: %#v", *m.ReserveStockMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveStock != nil && mm_atomic.LoadUint64(&m.afterReserveStockCounter) < 1 {
		m.t.Error("Expected call to OrdersRepositoryMock.ReserveStock")
	}
}

type mOrdersRepositoryMockStocks struct {
	mock               *OrdersRepositoryMock
	defaultExpectation *OrdersRepositoryMockStocksExpectation
	expectations       []*OrdersRepositoryMockStocksExpectation

	callArgs []*OrdersRepositoryMockStocksParams
	mutex    sync.RWMutex
}

// OrdersRepositoryMockStocksExpectation specifies expectation struct of the OrdersRepository.Stocks
type OrdersRepositoryMockStocksExpectation struct {
	mock    *OrdersRepositoryMock
	params  *OrdersRepositoryMockStocksParams
	results *OrdersRepositoryMockStocksResults
	Counter uint64
}

// OrdersRepositoryMockStocksParams contains parameters of the OrdersRepository.Stocks
type OrdersRepositoryMockStocksParams struct {
	ctx context.Context
	sku uint32
}

// OrdersRepositoryMockStocksResults contains results of the OrdersRepository.Stocks
type OrdersRepositoryMockStocksResults struct {
	sa1 []Stock
	err error
}

// Expect sets up expected params for OrdersRepository.Stocks
func (mmStocks *mOrdersRepositoryMockStocks) Expect(ctx context.Context, sku uint32) *mOrdersRepositoryMockStocks {
	if mmStocks.mock.funcStocks != nil {
		mmStocks.mock.t.Fatalf("OrdersRepositoryMock.Stocks mock is already set by Set")
	}

	if mmStocks.defaultExpectation == nil {
		mmStocks.defaultExpectation = &OrdersRepositoryMockStocksExpectation{}
	}

	mmStocks.defaultExpectation.params = &OrdersRepositoryMockStocksParams{ctx, sku}
	for _, e := range mmStocks.expectations {
		if minimock.Equal(e.params, mmStocks.defaultExpectation.params) {
			mmStocks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStocks.defaultExpectation.params)
		}
	}

	return mmStocks
}

// Inspect accepts an inspector function that has same arguments as the OrdersRepository.Stocks
func (mmStocks *mOrdersRepositoryMockStocks) Inspect(f func(ctx context.Context, sku uint32)) *mOrdersRepositoryMockStocks {
	if mmStocks.mock.inspectFuncStocks != nil {
		mmStocks.mock.t.Fatalf("Inspect function is already set for OrdersRepositoryMock.Stocks")
	}

	mmStocks.mock.inspectFuncStocks = f

	return mmStocks
}

// Return sets up results that will be returned by OrdersRepository.Stocks
func (mmStocks *mOrdersRepositoryMockStocks) Return(sa1 []Stock, err error) *OrdersRepositoryMock {
	if mmStocks.mock.funcStocks != nil {
		mmStocks.mock.t.Fatalf("OrdersRepositoryMock.Stocks mock is already set by Set")
	}

	if mmStocks.defaultExpectation == nil {
		mmStocks.defaultExpectation = &OrdersRepositoryMockStocksExpectation{mock: mmStocks.mock}
	}
	mmStocks.defaultExpectation.results = &OrdersRepositoryMockStocksResults{sa1, err}
	return mmStocks.mock
}

// Set uses given function f to mock the OrdersRepository.Stocks method
func (mmStocks *mOrdersRepositoryMockStocks) Set(f func(ctx context.Context, sku uint32) (sa1 []Stock, err error)) *OrdersRepositoryMock {
	if mmStocks.defaultExpectation != nil {
		mmStocks.mock.t.Fatalf("Default expectation is already set for the OrdersRepository.Stocks method")
	}

	if len(mmStocks.expectations) > 0 {
		mmStocks.mock.t.Fatalf("Some expectations are already set for the OrdersRepository.Stocks method")
	}

	mmStocks.mock.funcStocks = f
	return mmStocks.mock
}

// When sets expectation for the OrdersRepository.Stocks which will trigger the result defined by the following
// Then helper
func (mmStocks *mOrdersRepositoryMockStocks) When(ctx context.Context, sku uint32) *OrdersRepositoryMockStocksExpectation {
	if mmStocks.mock.funcStocks != nil {
		mmStocks.mock.t.Fatalf("OrdersRepositoryMock.Stocks mock is already set by Set")
	}

	expectation := &OrdersRepositoryMockStocksExpectation{
		mock:   mmStocks.mock,
		params: &OrdersRepositoryMockStocksParams{ctx, sku},
	}
	mmStocks.expectations = append(mmStocks.expectations, expectation)
	return expectation
}

// Then sets up OrdersRepository.Stocks return parameters for the expectation previously defined by the When method
func (e *OrdersRepositoryMockStocksExpectation) Then(sa1 []Stock, err error) *OrdersRepositoryMock {
	e.results = &OrdersRepositoryMockStocksResults{sa1, err}
	return e.mock
}

// Stocks implements OrdersRepository
func (mmStocks *OrdersRepositoryMock) Stocks(ctx context.Context, sku uint32) (sa1 []Stock, err error) {
	mm_atomic.AddUint64(&mmStocks.beforeStocksCounter, 1)
	defer mm_atomic.AddUint64(&mmStocks.afterStocksCounter, 1)

	if mmStocks.inspectFuncStocks != nil {
		mmStocks.inspectFuncStocks(ctx, sku)
	}

	mm_params := &OrdersRepositoryMockStocksParams{ctx, sku}

	// Record call args
	mmStocks.StocksMock.mutex.Lock()
	mmStocks.StocksMock.callArgs = append(mmStocks.StocksMock.callArgs, mm_params)
	mmStocks.StocksMock.mutex.Unlock()

	for _, e := range mmStocks.StocksMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmStocks.StocksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStocks.StocksMock.defaultExpectation.Counter, 1)
		mm_want := mmStocks.StocksMock.defaultExpectation.params
		mm_got := OrdersRepositoryMockStocksParams{ctx, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStocks.t.Errorf("OrdersRepositoryMock.Stocks got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStocks.StocksMock.defaultExpectation.results
		if mm_results == nil {
			mmStocks.t.Fatal("No results are set for the OrdersRepositoryMock.Stocks")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmStocks.funcStocks != nil {
		return mmStocks.funcStocks(ctx, sku)
	}
	mmStocks.t.Fatalf("Unexpected call to OrdersRepositoryMock.Stocks. %v %v", ctx, sku)
	return
}

// StocksAfterCounter returns a count of finished OrdersRepositoryMock.Stocks invocations
func (mmStocks *OrdersRepositoryMock) StocksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStocks.afterStocksCounter)
}

// StocksBeforeCounter returns a count of OrdersRepositoryMock.Stocks invocations
func (mmStocks *OrdersRepositoryMock) StocksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStocks.beforeStocksCounter)
}

// Calls returns a list of arguments used in each call to OrdersRepositoryMock.Stocks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStocks *mOrdersRepositoryMockStocks) Calls() []*OrdersRepositoryMockStocksParams {
	mmStocks.mutex.RLock()

	argCopy := make([]*OrdersRepositoryMockStocksParams, len(mmStocks.callArgs))
	copy(argCopy, mmStocks.callArgs)

	mmStocks.mutex.RUnlock()

	return argCopy
}

// MinimockStocksDone returns true if the count of the Stocks invocations corresponds
// the number of defined expectations
func (m *OrdersRepositoryMock) MinimockStocksDone() bool {
	for _, e := range m.StocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StocksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStocksCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStocks != nil && mm_atomic.LoadUint64(&m.afterStocksCounter) < 1 {
		return false
	}
	return true
}

// MinimockStocksInspect logs each unmet expectation
func (m *OrdersRepositoryMock) MinimockStocksInspect() {
	for _, e := range m.StocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersRepositoryMock.Stocks with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StocksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStocksCounter) < 1 {
		if m.StocksMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrdersRepositoryMock.Stocks")
		} else {
			m.t.Errorf("Expected call to OrdersRepositoryMock.Stocks with params: %#v", *m.StocksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStocks != nil && mm_atomic.LoadUint64(&m.afterStocksCounter) < 1 {
		m.t.Error("Expected call to OrdersRepositoryMock.Stocks")
	}
}

type mOrdersRepositoryMockUnReserveItems struct {
	mock               *OrdersRepositoryMock
	defaultExpectation *OrdersRepositoryMockUnReserveItemsExpectation
	expectations       []*OrdersRepositoryMockUnReserveItemsExpectation

	callArgs []*OrdersRepositoryMockUnReserveItemsParams
	mutex    sync.RWMutex
}

// OrdersRepositoryMockUnReserveItemsExpectation specifies expectation struct of the OrdersRepository.UnReserveItems
type OrdersRepositoryMockUnReserveItemsExpectation struct {
	mock    *OrdersRepositoryMock
	params  *OrdersRepositoryMockUnReserveItemsParams
	results *OrdersRepositoryMockUnReserveItemsResults
	Counter uint64
}

// OrdersRepositoryMockUnReserveItemsParams contains parameters of the OrdersRepository.UnReserveItems
type OrdersRepositoryMockUnReserveItemsParams struct {
	ctx     context.Context
	orderID int64
}

// OrdersRepositoryMockUnReserveItemsResults contains results of the OrdersRepository.UnReserveItems
type OrdersRepositoryMockUnReserveItemsResults struct {
	err error
}

// Expect sets up expected params for OrdersRepository.UnReserveItems
func (mmUnReserveItems *mOrdersRepositoryMockUnReserveItems) Expect(ctx context.Context, orderID int64) *mOrdersRepositoryMockUnReserveItems {
	if mmUnReserveItems.mock.funcUnReserveItems != nil {
		mmUnReserveItems.mock.t.Fatalf("OrdersRepositoryMock.UnReserveItems mock is already set by Set")
	}

	if mmUnReserveItems.defaultExpectation == nil {
		mmUnReserveItems.defaultExpectation = &OrdersRepositoryMockUnReserveItemsExpectation{}
	}

	mmUnReserveItems.defaultExpectation.params = &OrdersRepositoryMockUnReserveItemsParams{ctx, orderID}
	for _, e := range mmUnReserveItems.expectations {
		if minimock.Equal(e.params, mmUnReserveItems.defaultExpectation.params) {
			mmUnReserveItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnReserveItems.defaultExpectation.params)
		}
	}

	return mmUnReserveItems
}

// Inspect accepts an inspector function that has same arguments as the OrdersRepository.UnReserveItems
func (mmUnReserveItems *mOrdersRepositoryMockUnReserveItems) Inspect(f func(ctx context.Context, orderID int64)) *mOrdersRepositoryMockUnReserveItems {
	if mmUnReserveItems.mock.inspectFuncUnReserveItems != nil {
		mmUnReserveItems.mock.t.Fatalf("Inspect function is already set for OrdersRepositoryMock.UnReserveItems")
	}

	mmUnReserveItems.mock.inspectFuncUnReserveItems = f

	return mmUnReserveItems
}

// Return sets up results that will be returned by OrdersRepository.UnReserveItems
func (mmUnReserveItems *mOrdersRepositoryMockUnReserveItems) Return(err error) *OrdersRepositoryMock {
	if mmUnReserveItems.mock.funcUnReserveItems != nil {
		mmUnReserveItems.mock.t.Fatalf("OrdersRepositoryMock.UnReserveItems mock is already set by Set")
	}

	if mmUnReserveItems.defaultExpectation == nil {
		mmUnReserveItems.defaultExpectation = &OrdersRepositoryMockUnReserveItemsExpectation{mock: mmUnReserveItems.mock}
	}
	mmUnReserveItems.defaultExpectation.results = &OrdersRepositoryMockUnReserveItemsResults{err}
	return mmUnReserveItems.mock
}

// Set uses given function f to mock the OrdersRepository.UnReserveItems method
func (mmUnReserveItems *mOrdersRepositoryMockUnReserveItems) Set(f func(ctx context.Context, orderID int64) (err error)) *OrdersRepositoryMock {
	if mmUnReserveItems.defaultExpectation != nil {
		mmUnReserveItems.mock.t.Fatalf("Default expectation is already set for the OrdersRepository.UnReserveItems method")
	}

	if len(mmUnReserveItems.expectations) > 0 {
		mmUnReserveItems.mock.t.Fatalf("Some expectations are already set for the OrdersRepository.UnReserveItems method")
	}

	mmUnReserveItems.mock.funcUnReserveItems = f
	return mmUnReserveItems.mock
}

// When sets expectation for the OrdersRepository.UnReserveItems which will trigger the result defined by the following
// Then helper
func (mmUnReserveItems *mOrdersRepositoryMockUnReserveItems) When(ctx context.Context, orderID int64) *OrdersRepositoryMockUnReserveItemsExpectation {
	if mmUnReserveItems.mock.funcUnReserveItems != nil {
		mmUnReserveItems.mock.t.Fatalf("OrdersRepositoryMock.UnReserveItems mock is already set by Set")
	}

	expectation := &OrdersRepositoryMockUnReserveItemsExpectation{
		mock:   mmUnReserveItems.mock,
		params: &OrdersRepositoryMockUnReserveItemsParams{ctx, orderID},
	}
	mmUnReserveItems.expectations = append(mmUnReserveItems.expectations, expectation)
	return expectation
}

// Then sets up OrdersRepository.UnReserveItems return parameters for the expectation previously defined by the When method
func (e *OrdersRepositoryMockUnReserveItemsExpectation) Then(err error) *OrdersRepositoryMock {
	e.results = &OrdersRepositoryMockUnReserveItemsResults{err}
	return e.mock
}

// UnReserveItems implements OrdersRepository
func (mmUnReserveItems *OrdersRepositoryMock) UnReserveItems(ctx context.Context, orderID int64) (err error) {
	mm_atomic.AddUint64(&mmUnReserveItems.beforeUnReserveItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmUnReserveItems.afterUnReserveItemsCounter, 1)

	if mmUnReserveItems.inspectFuncUnReserveItems != nil {
		mmUnReserveItems.inspectFuncUnReserveItems(ctx, orderID)
	}

	mm_params := &OrdersRepositoryMockUnReserveItemsParams{ctx, orderID}

	// Record call args
	mmUnReserveItems.UnReserveItemsMock.mutex.Lock()
	mmUnReserveItems.UnReserveItemsMock.callArgs = append(mmUnReserveItems.UnReserveItemsMock.callArgs, mm_params)
	mmUnReserveItems.UnReserveItemsMock.mutex.Unlock()

	for _, e := range mmUnReserveItems.UnReserveItemsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUnReserveItems.UnReserveItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnReserveItems.UnReserveItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmUnReserveItems.UnReserveItemsMock.defaultExpectation.params
		mm_got := OrdersRepositoryMockUnReserveItemsParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUnReserveItems.t.Errorf("OrdersRepositoryMock.UnReserveItems got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUnReserveItems.UnReserveItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmUnReserveItems.t.Fatal("No results are set for the OrdersRepositoryMock.UnReserveItems")
		}
		return (*mm_results).err
	}
	if mmUnReserveItems.funcUnReserveItems != nil {
		return mmUnReserveItems.funcUnReserveItems(ctx, orderID)
	}
	mmUnReserveItems.t.Fatalf("Unexpected call to OrdersRepositoryMock.UnReserveItems. %v %v", ctx, orderID)
	return
}

// UnReserveItemsAfterCounter returns a count of finished OrdersRepositoryMock.UnReserveItems invocations
func (mmUnReserveItems *OrdersRepositoryMock) UnReserveItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnReserveItems.afterUnReserveItemsCounter)
}

// UnReserveItemsBeforeCounter returns a count of OrdersRepositoryMock.UnReserveItems invocations
func (mmUnReserveItems *OrdersRepositoryMock) UnReserveItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnReserveItems.beforeUnReserveItemsCounter)
}

// Calls returns a list of arguments used in each call to OrdersRepositoryMock.UnReserveItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnReserveItems *mOrdersRepositoryMockUnReserveItems) Calls() []*OrdersRepositoryMockUnReserveItemsParams {
	mmUnReserveItems.mutex.RLock()

	argCopy := make([]*OrdersRepositoryMockUnReserveItemsParams, len(mmUnReserveItems.callArgs))
	copy(argCopy, mmUnReserveItems.callArgs)

	mmUnReserveItems.mutex.RUnlock()

	return argCopy
}

// MinimockUnReserveItemsDone returns true if the count of the UnReserveItems invocations corresponds
// the number of defined expectations
func (m *OrdersRepositoryMock) MinimockUnReserveItemsDone() bool {
	for _, e := range m.UnReserveItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnReserveItemsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnReserveItemsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnReserveItems != nil && mm_atomic.LoadUint64(&m.afterUnReserveItemsCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnReserveItemsInspect logs each unmet expectation
func (m *OrdersRepositoryMock) MinimockUnReserveItemsInspect() {
	for _, e := range m.UnReserveItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersRepositoryMock.UnReserveItems with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnReserveItemsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnReserveItemsCounter) < 1 {
		if m.UnReserveItemsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrdersRepositoryMock.UnReserveItems")
		} else {
			m.t.Errorf("Expected call to OrdersRepositoryMock.UnReserveItems with params: %#v", *m.UnReserveItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnReserveItems != nil && mm_atomic.LoadUint64(&m.afterUnReserveItemsCounter) < 1 {
		m.t.Error("Expected call to OrdersRepositoryMock.UnReserveItems")
	}
}

type mOrdersRepositoryMockUpdateOrderStatus struct {
	mock               *OrdersRepositoryMock
	defaultExpectation *OrdersRepositoryMockUpdateOrderStatusExpectation
	expectations       []*OrdersRepositoryMockUpdateOrderStatusExpectation

	callArgs []*OrdersRepositoryMockUpdateOrderStatusParams
	mutex    sync.RWMutex
}

// OrdersRepositoryMockUpdateOrderStatusExpectation specifies expectation struct of the OrdersRepository.UpdateOrderStatus
type OrdersRepositoryMockUpdateOrderStatusExpectation struct {
	mock    *OrdersRepositoryMock
	params  *OrdersRepositoryMockUpdateOrderStatusParams
	results *OrdersRepositoryMockUpdateOrderStatusResults
	Counter uint64
}

// OrdersRepositoryMockUpdateOrderStatusParams contains parameters of the OrdersRepository.UpdateOrderStatus
type OrdersRepositoryMockUpdateOrderStatusParams struct {
	ctx          context.Context
	id           int64
	status       string
	statusBefore string
}

// OrdersRepositoryMockUpdateOrderStatusResults contains results of the OrdersRepository.UpdateOrderStatus
type OrdersRepositoryMockUpdateOrderStatusResults struct {
	err error
}

// Expect sets up expected params for OrdersRepository.UpdateOrderStatus
func (mmUpdateOrderStatus *mOrdersRepositoryMockUpdateOrderStatus) Expect(ctx context.Context, id int64, status string, statusBefore string) *mOrdersRepositoryMockUpdateOrderStatus {
	if mmUpdateOrderStatus.mock.funcUpdateOrderStatus != nil {
		mmUpdateOrderStatus.mock.t.Fatalf("OrdersRepositoryMock.UpdateOrderStatus mock is already set by Set")
	}

	if mmUpdateOrderStatus.defaultExpectation == nil {
		mmUpdateOrderStatus.defaultExpectation = &OrdersRepositoryMockUpdateOrderStatusExpectation{}
	}

	mmUpdateOrderStatus.defaultExpectation.params = &OrdersRepositoryMockUpdateOrderStatusParams{ctx, id, status, statusBefore}
	for _, e := range mmUpdateOrderStatus.expectations {
		if minimock.Equal(e.params, mmUpdateOrderStatus.defaultExpectation.params) {
			mmUpdateOrderStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOrderStatus.defaultExpectation.params)
		}
	}

	return mmUpdateOrderStatus
}

// Inspect accepts an inspector function that has same arguments as the OrdersRepository.UpdateOrderStatus
func (mmUpdateOrderStatus *mOrdersRepositoryMockUpdateOrderStatus) Inspect(f func(ctx context.Context, id int64, status string, statusBefore string)) *mOrdersRepositoryMockUpdateOrderStatus {
	if mmUpdateOrderStatus.mock.inspectFuncUpdateOrderStatus != nil {
		mmUpdateOrderStatus.mock.t.Fatalf("Inspect function is already set for OrdersRepositoryMock.UpdateOrderStatus")
	}

	mmUpdateOrderStatus.mock.inspectFuncUpdateOrderStatus = f

	return mmUpdateOrderStatus
}

// Return sets up results that will be returned by OrdersRepository.UpdateOrderStatus
func (mmUpdateOrderStatus *mOrdersRepositoryMockUpdateOrderStatus) Return(err error) *OrdersRepositoryMock {
	if mmUpdateOrderStatus.mock.funcUpdateOrderStatus != nil {
		mmUpdateOrderStatus.mock.t.Fatalf("OrdersRepositoryMock.UpdateOrderStatus mock is already set by Set")
	}

	if mmUpdateOrderStatus.defaultExpectation == nil {
		mmUpdateOrderStatus.defaultExpectation = &OrdersRepositoryMockUpdateOrderStatusExpectation{mock: mmUpdateOrderStatus.mock}
	}
	mmUpdateOrderStatus.defaultExpectation.results = &OrdersRepositoryMockUpdateOrderStatusResults{err}
	return mmUpdateOrderStatus.mock
}

// Set uses given function f to mock the OrdersRepository.UpdateOrderStatus method
func (mmUpdateOrderStatus *mOrdersRepositoryMockUpdateOrderStatus) Set(f func(ctx context.Context, id int64, status string, statusBefore string) (err error)) *OrdersRepositoryMock {
	if mmUpdateOrderStatus.defaultExpectation != nil {
		mmUpdateOrderStatus.mock.t.Fatalf("Default expectation is already set for the OrdersRepository.UpdateOrderStatus method")
	}

	if len(mmUpdateOrderStatus.expectations) > 0 {
		mmUpdateOrderStatus.mock.t.Fatalf("Some expectations are already set for the OrdersRepository.UpdateOrderStatus method")
	}

	mmUpdateOrderStatus.mock.funcUpdateOrderStatus = f
	return mmUpdateOrderStatus.mock
}

// When sets expectation for the OrdersRepository.UpdateOrderStatus which will trigger the result defined by the following
// Then helper
func (mmUpdateOrderStatus *mOrdersRepositoryMockUpdateOrderStatus) When(ctx context.Context, id int64, status string, statusBefore string) *OrdersRepositoryMockUpdateOrderStatusExpectation {
	if mmUpdateOrderStatus.mock.funcUpdateOrderStatus != nil {
		mmUpdateOrderStatus.mock.t.Fatalf("OrdersRepositoryMock.UpdateOrderStatus mock is already set by Set")
	}

	expectation := &OrdersRepositoryMockUpdateOrderStatusExpectation{
		mock:   mmUpdateOrderStatus.mock,
		params: &OrdersRepositoryMockUpdateOrderStatusParams{ctx, id, status, statusBefore},
	}
	mmUpdateOrderStatus.expectations = append(mmUpdateOrderStatus.expectations, expectation)
	return expectation
}

// Then sets up OrdersRepository.UpdateOrderStatus return parameters for the expectation previously defined by the When method
func (e *OrdersRepositoryMockUpdateOrderStatusExpectation) Then(err error) *OrdersRepositoryMock {
	e.results = &OrdersRepositoryMockUpdateOrderStatusResults{err}
	return e.mock
}

// UpdateOrderStatus implements OrdersRepository
func (mmUpdateOrderStatus *OrdersRepositoryMock) UpdateOrderStatus(ctx context.Context, id int64, status string, statusBefore string) (err error) {
	mm_atomic.AddUint64(&mmUpdateOrderStatus.beforeUpdateOrderStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOrderStatus.afterUpdateOrderStatusCounter, 1)

	if mmUpdateOrderStatus.inspectFuncUpdateOrderStatus != nil {
		mmUpdateOrderStatus.inspectFuncUpdateOrderStatus(ctx, id, status, statusBefore)
	}

	mm_params := &OrdersRepositoryMockUpdateOrderStatusParams{ctx, id, status, statusBefore}

	// Record call args
	mmUpdateOrderStatus.UpdateOrderStatusMock.mutex.Lock()
	mmUpdateOrderStatus.UpdateOrderStatusMock.callArgs = append(mmUpdateOrderStatus.UpdateOrderStatusMock.callArgs, mm_params)
	mmUpdateOrderStatus.UpdateOrderStatusMock.mutex.Unlock()

	for _, e := range mmUpdateOrderStatus.UpdateOrderStatusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateOrderStatus.UpdateOrderStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOrderStatus.UpdateOrderStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOrderStatus.UpdateOrderStatusMock.defaultExpectation.params
		mm_got := OrdersRepositoryMockUpdateOrderStatusParams{ctx, id, status, statusBefore}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOrderStatus.t.Errorf("OrdersRepositoryMock.UpdateOrderStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOrderStatus.UpdateOrderStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateOrderStatus.t.Fatal("No results are set for the OrdersRepositoryMock.UpdateOrderStatus")
		}
		return (*mm_results).err
	}
	if mmUpdateOrderStatus.funcUpdateOrderStatus != nil {
		return mmUpdateOrderStatus.funcUpdateOrderStatus(ctx, id, status, statusBefore)
	}
	mmUpdateOrderStatus.t.Fatalf("Unexpected call to OrdersRepositoryMock.UpdateOrderStatus. %v %v %v %v", ctx, id, status, statusBefore)
	return
}

// UpdateOrderStatusAfterCounter returns a count of finished OrdersRepositoryMock.UpdateOrderStatus invocations
func (mmUpdateOrderStatus *OrdersRepositoryMock) UpdateOrderStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrderStatus.afterUpdateOrderStatusCounter)
}

// UpdateOrderStatusBeforeCounter returns a count of OrdersRepositoryMock.UpdateOrderStatus invocations
func (mmUpdateOrderStatus *OrdersRepositoryMock) UpdateOrderStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrderStatus.beforeUpdateOrderStatusCounter)
}

// Calls returns a list of arguments used in each call to OrdersRepositoryMock.UpdateOrderStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOrderStatus *mOrdersRepositoryMockUpdateOrderStatus) Calls() []*OrdersRepositoryMockUpdateOrderStatusParams {
	mmUpdateOrderStatus.mutex.RLock()

	argCopy := make([]*OrdersRepositoryMockUpdateOrderStatusParams, len(mmUpdateOrderStatus.callArgs))
	copy(argCopy, mmUpdateOrderStatus.callArgs)

	mmUpdateOrderStatus.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOrderStatusDone returns true if the count of the UpdateOrderStatus invocations corresponds
// the number of defined expectations
func (m *OrdersRepositoryMock) MinimockUpdateOrderStatusDone() bool {
	for _, e := range m.UpdateOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderStatusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrderStatus != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderStatusCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateOrderStatusInspect logs each unmet expectation
func (m *OrdersRepositoryMock) MinimockUpdateOrderStatusInspect() {
	for _, e := range m.UpdateOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersRepositoryMock.UpdateOrderStatus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderStatusCounter) < 1 {
		if m.UpdateOrderStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrdersRepositoryMock.UpdateOrderStatus")
		} else {
			m.t.Errorf("Expected call to OrdersRepositoryMock.UpdateOrderStatus with params: %#v", *m.UpdateOrderStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrderStatus != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderStatusCounter) < 1 {
		m.t.Error("Expected call to OrdersRepositoryMock.UpdateOrderStatus")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrdersRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateOrderInspect()

		m.MinimockGetOrderInspect()

		m.MinimockRemoveSoldItemsInspect()

		m.MinimockReserveStockInspect()

		m.MinimockStocksInspect()

		m.MinimockUnReserveItemsInspect()

		m.MinimockUpdateOrderStatusInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrdersRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrdersRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateOrderDone() &&
		m.MinimockGetOrderDone() &&
		m.MinimockRemoveSoldItemsDone() &&
		m.MinimockReserveStockDone() &&
		m.MinimockStocksDone() &&
		m.MinimockUnReserveItemsDone() &&
		m.MinimockUpdateOrderStatusDone()
}
