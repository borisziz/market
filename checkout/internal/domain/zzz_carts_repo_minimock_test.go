package domain

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/checkout/internal/domain.CartsRepository -o ./zzz_carts_repo_minimock_test.go -n CartsRepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CartsRepositoryMock implements CartsRepository
type CartsRepositoryMock struct {
	t minimock.Tester

	funcAddToCart          func(ctx context.Context, user int64, sku uint32, count uint16) (err error)
	inspectFuncAddToCart   func(ctx context.Context, user int64, sku uint32, count uint16)
	afterAddToCartCounter  uint64
	beforeAddToCartCounter uint64
	AddToCartMock          mCartsRepositoryMockAddToCart

	funcDeleteCart          func(ctx context.Context, user int64) (err error)
	inspectFuncDeleteCart   func(ctx context.Context, user int64)
	afterDeleteCartCounter  uint64
	beforeDeleteCartCounter uint64
	DeleteCartMock          mCartsRepositoryMockDeleteCart

	funcDeleteFromCart          func(ctx context.Context, user int64, sku uint32, count uint16, full bool) (err error)
	inspectFuncDeleteFromCart   func(ctx context.Context, user int64, sku uint32, count uint16, full bool)
	afterDeleteFromCartCounter  uint64
	beforeDeleteFromCartCounter uint64
	DeleteFromCartMock          mCartsRepositoryMockDeleteFromCart

	funcGetCart          func(ctx context.Context, user int64) (ca1 []CartItem, err error)
	inspectFuncGetCart   func(ctx context.Context, user int64)
	afterGetCartCounter  uint64
	beforeGetCartCounter uint64
	GetCartMock          mCartsRepositoryMockGetCart

	funcGetCartItem          func(ctx context.Context, user int64, sku uint32) (cp1 *CartItem, err error)
	inspectFuncGetCartItem   func(ctx context.Context, user int64, sku uint32)
	afterGetCartItemCounter  uint64
	beforeGetCartItemCounter uint64
	GetCartItemMock          mCartsRepositoryMockGetCartItem
}

// NewCartsRepositoryMock returns a mock for CartsRepository
func NewCartsRepositoryMock(t minimock.Tester) *CartsRepositoryMock {
	m := &CartsRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddToCartMock = mCartsRepositoryMockAddToCart{mock: m}
	m.AddToCartMock.callArgs = []*CartsRepositoryMockAddToCartParams{}

	m.DeleteCartMock = mCartsRepositoryMockDeleteCart{mock: m}
	m.DeleteCartMock.callArgs = []*CartsRepositoryMockDeleteCartParams{}

	m.DeleteFromCartMock = mCartsRepositoryMockDeleteFromCart{mock: m}
	m.DeleteFromCartMock.callArgs = []*CartsRepositoryMockDeleteFromCartParams{}

	m.GetCartMock = mCartsRepositoryMockGetCart{mock: m}
	m.GetCartMock.callArgs = []*CartsRepositoryMockGetCartParams{}

	m.GetCartItemMock = mCartsRepositoryMockGetCartItem{mock: m}
	m.GetCartItemMock.callArgs = []*CartsRepositoryMockGetCartItemParams{}

	return m
}

type mCartsRepositoryMockAddToCart struct {
	mock               *CartsRepositoryMock
	defaultExpectation *CartsRepositoryMockAddToCartExpectation
	expectations       []*CartsRepositoryMockAddToCartExpectation

	callArgs []*CartsRepositoryMockAddToCartParams
	mutex    sync.RWMutex
}

// CartsRepositoryMockAddToCartExpectation specifies expectation struct of the CartsRepository.AddToCart
type CartsRepositoryMockAddToCartExpectation struct {
	mock    *CartsRepositoryMock
	params  *CartsRepositoryMockAddToCartParams
	results *CartsRepositoryMockAddToCartResults
	Counter uint64
}

// CartsRepositoryMockAddToCartParams contains parameters of the CartsRepository.AddToCart
type CartsRepositoryMockAddToCartParams struct {
	ctx   context.Context
	user  int64
	sku   uint32
	count uint16
}

// CartsRepositoryMockAddToCartResults contains results of the CartsRepository.AddToCart
type CartsRepositoryMockAddToCartResults struct {
	err error
}

// Expect sets up expected params for CartsRepository.AddToCart
func (mmAddToCart *mCartsRepositoryMockAddToCart) Expect(ctx context.Context, user int64, sku uint32, count uint16) *mCartsRepositoryMockAddToCart {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CartsRepositoryMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &CartsRepositoryMockAddToCartExpectation{}
	}

	mmAddToCart.defaultExpectation.params = &CartsRepositoryMockAddToCartParams{ctx, user, sku, count}
	for _, e := range mmAddToCart.expectations {
		if minimock.Equal(e.params, mmAddToCart.defaultExpectation.params) {
			mmAddToCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddToCart.defaultExpectation.params)
		}
	}

	return mmAddToCart
}

// Inspect accepts an inspector function that has same arguments as the CartsRepository.AddToCart
func (mmAddToCart *mCartsRepositoryMockAddToCart) Inspect(f func(ctx context.Context, user int64, sku uint32, count uint16)) *mCartsRepositoryMockAddToCart {
	if mmAddToCart.mock.inspectFuncAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("Inspect function is already set for CartsRepositoryMock.AddToCart")
	}

	mmAddToCart.mock.inspectFuncAddToCart = f

	return mmAddToCart
}

// Return sets up results that will be returned by CartsRepository.AddToCart
func (mmAddToCart *mCartsRepositoryMockAddToCart) Return(err error) *CartsRepositoryMock {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CartsRepositoryMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &CartsRepositoryMockAddToCartExpectation{mock: mmAddToCart.mock}
	}
	mmAddToCart.defaultExpectation.results = &CartsRepositoryMockAddToCartResults{err}
	return mmAddToCart.mock
}

// Set uses given function f to mock the CartsRepository.AddToCart method
func (mmAddToCart *mCartsRepositoryMockAddToCart) Set(f func(ctx context.Context, user int64, sku uint32, count uint16) (err error)) *CartsRepositoryMock {
	if mmAddToCart.defaultExpectation != nil {
		mmAddToCart.mock.t.Fatalf("Default expectation is already set for the CartsRepository.AddToCart method")
	}

	if len(mmAddToCart.expectations) > 0 {
		mmAddToCart.mock.t.Fatalf("Some expectations are already set for the CartsRepository.AddToCart method")
	}

	mmAddToCart.mock.funcAddToCart = f
	return mmAddToCart.mock
}

// When sets expectation for the CartsRepository.AddToCart which will trigger the result defined by the following
// Then helper
func (mmAddToCart *mCartsRepositoryMockAddToCart) When(ctx context.Context, user int64, sku uint32, count uint16) *CartsRepositoryMockAddToCartExpectation {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CartsRepositoryMock.AddToCart mock is already set by Set")
	}

	expectation := &CartsRepositoryMockAddToCartExpectation{
		mock:   mmAddToCart.mock,
		params: &CartsRepositoryMockAddToCartParams{ctx, user, sku, count},
	}
	mmAddToCart.expectations = append(mmAddToCart.expectations, expectation)
	return expectation
}

// Then sets up CartsRepository.AddToCart return parameters for the expectation previously defined by the When method
func (e *CartsRepositoryMockAddToCartExpectation) Then(err error) *CartsRepositoryMock {
	e.results = &CartsRepositoryMockAddToCartResults{err}
	return e.mock
}

// AddToCart implements CartsRepository
func (mmAddToCart *CartsRepositoryMock) AddToCart(ctx context.Context, user int64, sku uint32, count uint16) (err error) {
	mm_atomic.AddUint64(&mmAddToCart.beforeAddToCartCounter, 1)
	defer mm_atomic.AddUint64(&mmAddToCart.afterAddToCartCounter, 1)

	if mmAddToCart.inspectFuncAddToCart != nil {
		mmAddToCart.inspectFuncAddToCart(ctx, user, sku, count)
	}

	mm_params := &CartsRepositoryMockAddToCartParams{ctx, user, sku, count}

	// Record call args
	mmAddToCart.AddToCartMock.mutex.Lock()
	mmAddToCart.AddToCartMock.callArgs = append(mmAddToCart.AddToCartMock.callArgs, mm_params)
	mmAddToCart.AddToCartMock.mutex.Unlock()

	for _, e := range mmAddToCart.AddToCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddToCart.AddToCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddToCart.AddToCartMock.defaultExpectation.Counter, 1)
		mm_want := mmAddToCart.AddToCartMock.defaultExpectation.params
		mm_got := CartsRepositoryMockAddToCartParams{ctx, user, sku, count}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddToCart.t.Errorf("CartsRepositoryMock.AddToCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddToCart.AddToCartMock.defaultExpectation.results
		if mm_results == nil {
			mmAddToCart.t.Fatal("No results are set for the CartsRepositoryMock.AddToCart")
		}
		return (*mm_results).err
	}
	if mmAddToCart.funcAddToCart != nil {
		return mmAddToCart.funcAddToCart(ctx, user, sku, count)
	}
	mmAddToCart.t.Fatalf("Unexpected call to CartsRepositoryMock.AddToCart. %v %v %v %v", ctx, user, sku, count)
	return
}

// AddToCartAfterCounter returns a count of finished CartsRepositoryMock.AddToCart invocations
func (mmAddToCart *CartsRepositoryMock) AddToCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCart.afterAddToCartCounter)
}

// AddToCartBeforeCounter returns a count of CartsRepositoryMock.AddToCart invocations
func (mmAddToCart *CartsRepositoryMock) AddToCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCart.beforeAddToCartCounter)
}

// Calls returns a list of arguments used in each call to CartsRepositoryMock.AddToCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddToCart *mCartsRepositoryMockAddToCart) Calls() []*CartsRepositoryMockAddToCartParams {
	mmAddToCart.mutex.RLock()

	argCopy := make([]*CartsRepositoryMockAddToCartParams, len(mmAddToCart.callArgs))
	copy(argCopy, mmAddToCart.callArgs)

	mmAddToCart.mutex.RUnlock()

	return argCopy
}

// MinimockAddToCartDone returns true if the count of the AddToCart invocations corresponds
// the number of defined expectations
func (m *CartsRepositoryMock) MinimockAddToCartDone() bool {
	for _, e := range m.AddToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToCart != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddToCartInspect logs each unmet expectation
func (m *CartsRepositoryMock) MinimockAddToCartInspect() {
	for _, e := range m.AddToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartsRepositoryMock.AddToCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		if m.AddToCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartsRepositoryMock.AddToCart")
		} else {
			m.t.Errorf("Expected call to CartsRepositoryMock.AddToCart with params: %#v", *m.AddToCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToCart != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		m.t.Error("Expected call to CartsRepositoryMock.AddToCart")
	}
}

type mCartsRepositoryMockDeleteCart struct {
	mock               *CartsRepositoryMock
	defaultExpectation *CartsRepositoryMockDeleteCartExpectation
	expectations       []*CartsRepositoryMockDeleteCartExpectation

	callArgs []*CartsRepositoryMockDeleteCartParams
	mutex    sync.RWMutex
}

// CartsRepositoryMockDeleteCartExpectation specifies expectation struct of the CartsRepository.DeleteCart
type CartsRepositoryMockDeleteCartExpectation struct {
	mock    *CartsRepositoryMock
	params  *CartsRepositoryMockDeleteCartParams
	results *CartsRepositoryMockDeleteCartResults
	Counter uint64
}

// CartsRepositoryMockDeleteCartParams contains parameters of the CartsRepository.DeleteCart
type CartsRepositoryMockDeleteCartParams struct {
	ctx  context.Context
	user int64
}

// CartsRepositoryMockDeleteCartResults contains results of the CartsRepository.DeleteCart
type CartsRepositoryMockDeleteCartResults struct {
	err error
}

// Expect sets up expected params for CartsRepository.DeleteCart
func (mmDeleteCart *mCartsRepositoryMockDeleteCart) Expect(ctx context.Context, user int64) *mCartsRepositoryMockDeleteCart {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartsRepositoryMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &CartsRepositoryMockDeleteCartExpectation{}
	}

	mmDeleteCart.defaultExpectation.params = &CartsRepositoryMockDeleteCartParams{ctx, user}
	for _, e := range mmDeleteCart.expectations {
		if minimock.Equal(e.params, mmDeleteCart.defaultExpectation.params) {
			mmDeleteCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCart.defaultExpectation.params)
		}
	}

	return mmDeleteCart
}

// Inspect accepts an inspector function that has same arguments as the CartsRepository.DeleteCart
func (mmDeleteCart *mCartsRepositoryMockDeleteCart) Inspect(f func(ctx context.Context, user int64)) *mCartsRepositoryMockDeleteCart {
	if mmDeleteCart.mock.inspectFuncDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("Inspect function is already set for CartsRepositoryMock.DeleteCart")
	}

	mmDeleteCart.mock.inspectFuncDeleteCart = f

	return mmDeleteCart
}

// Return sets up results that will be returned by CartsRepository.DeleteCart
func (mmDeleteCart *mCartsRepositoryMockDeleteCart) Return(err error) *CartsRepositoryMock {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartsRepositoryMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &CartsRepositoryMockDeleteCartExpectation{mock: mmDeleteCart.mock}
	}
	mmDeleteCart.defaultExpectation.results = &CartsRepositoryMockDeleteCartResults{err}
	return mmDeleteCart.mock
}

// Set uses given function f to mock the CartsRepository.DeleteCart method
func (mmDeleteCart *mCartsRepositoryMockDeleteCart) Set(f func(ctx context.Context, user int64) (err error)) *CartsRepositoryMock {
	if mmDeleteCart.defaultExpectation != nil {
		mmDeleteCart.mock.t.Fatalf("Default expectation is already set for the CartsRepository.DeleteCart method")
	}

	if len(mmDeleteCart.expectations) > 0 {
		mmDeleteCart.mock.t.Fatalf("Some expectations are already set for the CartsRepository.DeleteCart method")
	}

	mmDeleteCart.mock.funcDeleteCart = f
	return mmDeleteCart.mock
}

// When sets expectation for the CartsRepository.DeleteCart which will trigger the result defined by the following
// Then helper
func (mmDeleteCart *mCartsRepositoryMockDeleteCart) When(ctx context.Context, user int64) *CartsRepositoryMockDeleteCartExpectation {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartsRepositoryMock.DeleteCart mock is already set by Set")
	}

	expectation := &CartsRepositoryMockDeleteCartExpectation{
		mock:   mmDeleteCart.mock,
		params: &CartsRepositoryMockDeleteCartParams{ctx, user},
	}
	mmDeleteCart.expectations = append(mmDeleteCart.expectations, expectation)
	return expectation
}

// Then sets up CartsRepository.DeleteCart return parameters for the expectation previously defined by the When method
func (e *CartsRepositoryMockDeleteCartExpectation) Then(err error) *CartsRepositoryMock {
	e.results = &CartsRepositoryMockDeleteCartResults{err}
	return e.mock
}

// DeleteCart implements CartsRepository
func (mmDeleteCart *CartsRepositoryMock) DeleteCart(ctx context.Context, user int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteCart.beforeDeleteCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCart.afterDeleteCartCounter, 1)

	if mmDeleteCart.inspectFuncDeleteCart != nil {
		mmDeleteCart.inspectFuncDeleteCart(ctx, user)
	}

	mm_params := &CartsRepositoryMockDeleteCartParams{ctx, user}

	// Record call args
	mmDeleteCart.DeleteCartMock.mutex.Lock()
	mmDeleteCart.DeleteCartMock.callArgs = append(mmDeleteCart.DeleteCartMock.callArgs, mm_params)
	mmDeleteCart.DeleteCartMock.mutex.Unlock()

	for _, e := range mmDeleteCart.DeleteCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteCart.DeleteCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCart.DeleteCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCart.DeleteCartMock.defaultExpectation.params
		mm_got := CartsRepositoryMockDeleteCartParams{ctx, user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCart.t.Errorf("CartsRepositoryMock.DeleteCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCart.DeleteCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCart.t.Fatal("No results are set for the CartsRepositoryMock.DeleteCart")
		}
		return (*mm_results).err
	}
	if mmDeleteCart.funcDeleteCart != nil {
		return mmDeleteCart.funcDeleteCart(ctx, user)
	}
	mmDeleteCart.t.Fatalf("Unexpected call to CartsRepositoryMock.DeleteCart. %v %v", ctx, user)
	return
}

// DeleteCartAfterCounter returns a count of finished CartsRepositoryMock.DeleteCart invocations
func (mmDeleteCart *CartsRepositoryMock) DeleteCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCart.afterDeleteCartCounter)
}

// DeleteCartBeforeCounter returns a count of CartsRepositoryMock.DeleteCart invocations
func (mmDeleteCart *CartsRepositoryMock) DeleteCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCart.beforeDeleteCartCounter)
}

// Calls returns a list of arguments used in each call to CartsRepositoryMock.DeleteCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCart *mCartsRepositoryMockDeleteCart) Calls() []*CartsRepositoryMockDeleteCartParams {
	mmDeleteCart.mutex.RLock()

	argCopy := make([]*CartsRepositoryMockDeleteCartParams, len(mmDeleteCart.callArgs))
	copy(argCopy, mmDeleteCart.callArgs)

	mmDeleteCart.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCartDone returns true if the count of the DeleteCart invocations corresponds
// the number of defined expectations
func (m *CartsRepositoryMock) MinimockDeleteCartDone() bool {
	for _, e := range m.DeleteCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCart != nil && mm_atomic.LoadUint64(&m.afterDeleteCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteCartInspect logs each unmet expectation
func (m *CartsRepositoryMock) MinimockDeleteCartInspect() {
	for _, e := range m.DeleteCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartsRepositoryMock.DeleteCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCartCounter) < 1 {
		if m.DeleteCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartsRepositoryMock.DeleteCart")
		} else {
			m.t.Errorf("Expected call to CartsRepositoryMock.DeleteCart with params: %#v", *m.DeleteCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCart != nil && mm_atomic.LoadUint64(&m.afterDeleteCartCounter) < 1 {
		m.t.Error("Expected call to CartsRepositoryMock.DeleteCart")
	}
}

type mCartsRepositoryMockDeleteFromCart struct {
	mock               *CartsRepositoryMock
	defaultExpectation *CartsRepositoryMockDeleteFromCartExpectation
	expectations       []*CartsRepositoryMockDeleteFromCartExpectation

	callArgs []*CartsRepositoryMockDeleteFromCartParams
	mutex    sync.RWMutex
}

// CartsRepositoryMockDeleteFromCartExpectation specifies expectation struct of the CartsRepository.DeleteFromCart
type CartsRepositoryMockDeleteFromCartExpectation struct {
	mock    *CartsRepositoryMock
	params  *CartsRepositoryMockDeleteFromCartParams
	results *CartsRepositoryMockDeleteFromCartResults
	Counter uint64
}

// CartsRepositoryMockDeleteFromCartParams contains parameters of the CartsRepository.DeleteFromCart
type CartsRepositoryMockDeleteFromCartParams struct {
	ctx   context.Context
	user  int64
	sku   uint32
	count uint16
	full  bool
}

// CartsRepositoryMockDeleteFromCartResults contains results of the CartsRepository.DeleteFromCart
type CartsRepositoryMockDeleteFromCartResults struct {
	err error
}

// Expect sets up expected params for CartsRepository.DeleteFromCart
func (mmDeleteFromCart *mCartsRepositoryMockDeleteFromCart) Expect(ctx context.Context, user int64, sku uint32, count uint16, full bool) *mCartsRepositoryMockDeleteFromCart {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("CartsRepositoryMock.DeleteFromCart mock is already set by Set")
	}

	if mmDeleteFromCart.defaultExpectation == nil {
		mmDeleteFromCart.defaultExpectation = &CartsRepositoryMockDeleteFromCartExpectation{}
	}

	mmDeleteFromCart.defaultExpectation.params = &CartsRepositoryMockDeleteFromCartParams{ctx, user, sku, count, full}
	for _, e := range mmDeleteFromCart.expectations {
		if minimock.Equal(e.params, mmDeleteFromCart.defaultExpectation.params) {
			mmDeleteFromCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteFromCart.defaultExpectation.params)
		}
	}

	return mmDeleteFromCart
}

// Inspect accepts an inspector function that has same arguments as the CartsRepository.DeleteFromCart
func (mmDeleteFromCart *mCartsRepositoryMockDeleteFromCart) Inspect(f func(ctx context.Context, user int64, sku uint32, count uint16, full bool)) *mCartsRepositoryMockDeleteFromCart {
	if mmDeleteFromCart.mock.inspectFuncDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("Inspect function is already set for CartsRepositoryMock.DeleteFromCart")
	}

	mmDeleteFromCart.mock.inspectFuncDeleteFromCart = f

	return mmDeleteFromCart
}

// Return sets up results that will be returned by CartsRepository.DeleteFromCart
func (mmDeleteFromCart *mCartsRepositoryMockDeleteFromCart) Return(err error) *CartsRepositoryMock {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("CartsRepositoryMock.DeleteFromCart mock is already set by Set")
	}

	if mmDeleteFromCart.defaultExpectation == nil {
		mmDeleteFromCart.defaultExpectation = &CartsRepositoryMockDeleteFromCartExpectation{mock: mmDeleteFromCart.mock}
	}
	mmDeleteFromCart.defaultExpectation.results = &CartsRepositoryMockDeleteFromCartResults{err}
	return mmDeleteFromCart.mock
}

// Set uses given function f to mock the CartsRepository.DeleteFromCart method
func (mmDeleteFromCart *mCartsRepositoryMockDeleteFromCart) Set(f func(ctx context.Context, user int64, sku uint32, count uint16, full bool) (err error)) *CartsRepositoryMock {
	if mmDeleteFromCart.defaultExpectation != nil {
		mmDeleteFromCart.mock.t.Fatalf("Default expectation is already set for the CartsRepository.DeleteFromCart method")
	}

	if len(mmDeleteFromCart.expectations) > 0 {
		mmDeleteFromCart.mock.t.Fatalf("Some expectations are already set for the CartsRepository.DeleteFromCart method")
	}

	mmDeleteFromCart.mock.funcDeleteFromCart = f
	return mmDeleteFromCart.mock
}

// When sets expectation for the CartsRepository.DeleteFromCart which will trigger the result defined by the following
// Then helper
func (mmDeleteFromCart *mCartsRepositoryMockDeleteFromCart) When(ctx context.Context, user int64, sku uint32, count uint16, full bool) *CartsRepositoryMockDeleteFromCartExpectation {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("CartsRepositoryMock.DeleteFromCart mock is already set by Set")
	}

	expectation := &CartsRepositoryMockDeleteFromCartExpectation{
		mock:   mmDeleteFromCart.mock,
		params: &CartsRepositoryMockDeleteFromCartParams{ctx, user, sku, count, full},
	}
	mmDeleteFromCart.expectations = append(mmDeleteFromCart.expectations, expectation)
	return expectation
}

// Then sets up CartsRepository.DeleteFromCart return parameters for the expectation previously defined by the When method
func (e *CartsRepositoryMockDeleteFromCartExpectation) Then(err error) *CartsRepositoryMock {
	e.results = &CartsRepositoryMockDeleteFromCartResults{err}
	return e.mock
}

// DeleteFromCart implements CartsRepository
func (mmDeleteFromCart *CartsRepositoryMock) DeleteFromCart(ctx context.Context, user int64, sku uint32, count uint16, full bool) (err error) {
	mm_atomic.AddUint64(&mmDeleteFromCart.beforeDeleteFromCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteFromCart.afterDeleteFromCartCounter, 1)

	if mmDeleteFromCart.inspectFuncDeleteFromCart != nil {
		mmDeleteFromCart.inspectFuncDeleteFromCart(ctx, user, sku, count, full)
	}

	mm_params := &CartsRepositoryMockDeleteFromCartParams{ctx, user, sku, count, full}

	// Record call args
	mmDeleteFromCart.DeleteFromCartMock.mutex.Lock()
	mmDeleteFromCart.DeleteFromCartMock.callArgs = append(mmDeleteFromCart.DeleteFromCartMock.callArgs, mm_params)
	mmDeleteFromCart.DeleteFromCartMock.mutex.Unlock()

	for _, e := range mmDeleteFromCart.DeleteFromCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteFromCart.DeleteFromCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.params
		mm_got := CartsRepositoryMockDeleteFromCartParams{ctx, user, sku, count, full}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteFromCart.t.Errorf("CartsRepositoryMock.DeleteFromCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteFromCart.t.Fatal("No results are set for the CartsRepositoryMock.DeleteFromCart")
		}
		return (*mm_results).err
	}
	if mmDeleteFromCart.funcDeleteFromCart != nil {
		return mmDeleteFromCart.funcDeleteFromCart(ctx, user, sku, count, full)
	}
	mmDeleteFromCart.t.Fatalf("Unexpected call to CartsRepositoryMock.DeleteFromCart. %v %v %v %v %v", ctx, user, sku, count, full)
	return
}

// DeleteFromCartAfterCounter returns a count of finished CartsRepositoryMock.DeleteFromCart invocations
func (mmDeleteFromCart *CartsRepositoryMock) DeleteFromCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFromCart.afterDeleteFromCartCounter)
}

// DeleteFromCartBeforeCounter returns a count of CartsRepositoryMock.DeleteFromCart invocations
func (mmDeleteFromCart *CartsRepositoryMock) DeleteFromCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFromCart.beforeDeleteFromCartCounter)
}

// Calls returns a list of arguments used in each call to CartsRepositoryMock.DeleteFromCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteFromCart *mCartsRepositoryMockDeleteFromCart) Calls() []*CartsRepositoryMockDeleteFromCartParams {
	mmDeleteFromCart.mutex.RLock()

	argCopy := make([]*CartsRepositoryMockDeleteFromCartParams, len(mmDeleteFromCart.callArgs))
	copy(argCopy, mmDeleteFromCart.callArgs)

	mmDeleteFromCart.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteFromCartDone returns true if the count of the DeleteFromCart invocations corresponds
// the number of defined expectations
func (m *CartsRepositoryMock) MinimockDeleteFromCartDone() bool {
	for _, e := range m.DeleteFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFromCart != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteFromCartInspect logs each unmet expectation
func (m *CartsRepositoryMock) MinimockDeleteFromCartInspect() {
	for _, e := range m.DeleteFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartsRepositoryMock.DeleteFromCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		if m.DeleteFromCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartsRepositoryMock.DeleteFromCart")
		} else {
			m.t.Errorf("Expected call to CartsRepositoryMock.DeleteFromCart with params: %#v", *m.DeleteFromCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFromCart != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		m.t.Error("Expected call to CartsRepositoryMock.DeleteFromCart")
	}
}

type mCartsRepositoryMockGetCart struct {
	mock               *CartsRepositoryMock
	defaultExpectation *CartsRepositoryMockGetCartExpectation
	expectations       []*CartsRepositoryMockGetCartExpectation

	callArgs []*CartsRepositoryMockGetCartParams
	mutex    sync.RWMutex
}

// CartsRepositoryMockGetCartExpectation specifies expectation struct of the CartsRepository.GetCart
type CartsRepositoryMockGetCartExpectation struct {
	mock    *CartsRepositoryMock
	params  *CartsRepositoryMockGetCartParams
	results *CartsRepositoryMockGetCartResults
	Counter uint64
}

// CartsRepositoryMockGetCartParams contains parameters of the CartsRepository.GetCart
type CartsRepositoryMockGetCartParams struct {
	ctx  context.Context
	user int64
}

// CartsRepositoryMockGetCartResults contains results of the CartsRepository.GetCart
type CartsRepositoryMockGetCartResults struct {
	ca1 []CartItem
	err error
}

// Expect sets up expected params for CartsRepository.GetCart
func (mmGetCart *mCartsRepositoryMockGetCart) Expect(ctx context.Context, user int64) *mCartsRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartsRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartsRepositoryMockGetCartExpectation{}
	}

	mmGetCart.defaultExpectation.params = &CartsRepositoryMockGetCartParams{ctx, user}
	for _, e := range mmGetCart.expectations {
		if minimock.Equal(e.params, mmGetCart.defaultExpectation.params) {
			mmGetCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCart.defaultExpectation.params)
		}
	}

	return mmGetCart
}

// Inspect accepts an inspector function that has same arguments as the CartsRepository.GetCart
func (mmGetCart *mCartsRepositoryMockGetCart) Inspect(f func(ctx context.Context, user int64)) *mCartsRepositoryMockGetCart {
	if mmGetCart.mock.inspectFuncGetCart != nil {
		mmGetCart.mock.t.Fatalf("Inspect function is already set for CartsRepositoryMock.GetCart")
	}

	mmGetCart.mock.inspectFuncGetCart = f

	return mmGetCart
}

// Return sets up results that will be returned by CartsRepository.GetCart
func (mmGetCart *mCartsRepositoryMockGetCart) Return(ca1 []CartItem, err error) *CartsRepositoryMock {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartsRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartsRepositoryMockGetCartExpectation{mock: mmGetCart.mock}
	}
	mmGetCart.defaultExpectation.results = &CartsRepositoryMockGetCartResults{ca1, err}
	return mmGetCart.mock
}

// Set uses given function f to mock the CartsRepository.GetCart method
func (mmGetCart *mCartsRepositoryMockGetCart) Set(f func(ctx context.Context, user int64) (ca1 []CartItem, err error)) *CartsRepositoryMock {
	if mmGetCart.defaultExpectation != nil {
		mmGetCart.mock.t.Fatalf("Default expectation is already set for the CartsRepository.GetCart method")
	}

	if len(mmGetCart.expectations) > 0 {
		mmGetCart.mock.t.Fatalf("Some expectations are already set for the CartsRepository.GetCart method")
	}

	mmGetCart.mock.funcGetCart = f
	return mmGetCart.mock
}

// When sets expectation for the CartsRepository.GetCart which will trigger the result defined by the following
// Then helper
func (mmGetCart *mCartsRepositoryMockGetCart) When(ctx context.Context, user int64) *CartsRepositoryMockGetCartExpectation {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartsRepositoryMock.GetCart mock is already set by Set")
	}

	expectation := &CartsRepositoryMockGetCartExpectation{
		mock:   mmGetCart.mock,
		params: &CartsRepositoryMockGetCartParams{ctx, user},
	}
	mmGetCart.expectations = append(mmGetCart.expectations, expectation)
	return expectation
}

// Then sets up CartsRepository.GetCart return parameters for the expectation previously defined by the When method
func (e *CartsRepositoryMockGetCartExpectation) Then(ca1 []CartItem, err error) *CartsRepositoryMock {
	e.results = &CartsRepositoryMockGetCartResults{ca1, err}
	return e.mock
}

// GetCart implements CartsRepository
func (mmGetCart *CartsRepositoryMock) GetCart(ctx context.Context, user int64) (ca1 []CartItem, err error) {
	mm_atomic.AddUint64(&mmGetCart.beforeGetCartCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCart.afterGetCartCounter, 1)

	if mmGetCart.inspectFuncGetCart != nil {
		mmGetCart.inspectFuncGetCart(ctx, user)
	}

	mm_params := &CartsRepositoryMockGetCartParams{ctx, user}

	// Record call args
	mmGetCart.GetCartMock.mutex.Lock()
	mmGetCart.GetCartMock.callArgs = append(mmGetCart.GetCartMock.callArgs, mm_params)
	mmGetCart.GetCartMock.mutex.Unlock()

	for _, e := range mmGetCart.GetCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmGetCart.GetCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCart.GetCartMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCart.GetCartMock.defaultExpectation.params
		mm_got := CartsRepositoryMockGetCartParams{ctx, user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCart.t.Errorf("CartsRepositoryMock.GetCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCart.GetCartMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCart.t.Fatal("No results are set for the CartsRepositoryMock.GetCart")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmGetCart.funcGetCart != nil {
		return mmGetCart.funcGetCart(ctx, user)
	}
	mmGetCart.t.Fatalf("Unexpected call to CartsRepositoryMock.GetCart. %v %v", ctx, user)
	return
}

// GetCartAfterCounter returns a count of finished CartsRepositoryMock.GetCart invocations
func (mmGetCart *CartsRepositoryMock) GetCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.afterGetCartCounter)
}

// GetCartBeforeCounter returns a count of CartsRepositoryMock.GetCart invocations
func (mmGetCart *CartsRepositoryMock) GetCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.beforeGetCartCounter)
}

// Calls returns a list of arguments used in each call to CartsRepositoryMock.GetCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCart *mCartsRepositoryMockGetCart) Calls() []*CartsRepositoryMockGetCartParams {
	mmGetCart.mutex.RLock()

	argCopy := make([]*CartsRepositoryMockGetCartParams, len(mmGetCart.callArgs))
	copy(argCopy, mmGetCart.callArgs)

	mmGetCart.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartDone returns true if the count of the GetCart invocations corresponds
// the number of defined expectations
func (m *CartsRepositoryMock) MinimockGetCartDone() bool {
	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCart != nil && mm_atomic.LoadUint64(&m.afterGetCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCartInspect logs each unmet expectation
func (m *CartsRepositoryMock) MinimockGetCartInspect() {
	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartsRepositoryMock.GetCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartCounter) < 1 {
		if m.GetCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartsRepositoryMock.GetCart")
		} else {
			m.t.Errorf("Expected call to CartsRepositoryMock.GetCart with params: %#v", *m.GetCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCart != nil && mm_atomic.LoadUint64(&m.afterGetCartCounter) < 1 {
		m.t.Error("Expected call to CartsRepositoryMock.GetCart")
	}
}

type mCartsRepositoryMockGetCartItem struct {
	mock               *CartsRepositoryMock
	defaultExpectation *CartsRepositoryMockGetCartItemExpectation
	expectations       []*CartsRepositoryMockGetCartItemExpectation

	callArgs []*CartsRepositoryMockGetCartItemParams
	mutex    sync.RWMutex
}

// CartsRepositoryMockGetCartItemExpectation specifies expectation struct of the CartsRepository.GetCartItem
type CartsRepositoryMockGetCartItemExpectation struct {
	mock    *CartsRepositoryMock
	params  *CartsRepositoryMockGetCartItemParams
	results *CartsRepositoryMockGetCartItemResults
	Counter uint64
}

// CartsRepositoryMockGetCartItemParams contains parameters of the CartsRepository.GetCartItem
type CartsRepositoryMockGetCartItemParams struct {
	ctx  context.Context
	user int64
	sku  uint32
}

// CartsRepositoryMockGetCartItemResults contains results of the CartsRepository.GetCartItem
type CartsRepositoryMockGetCartItemResults struct {
	cp1 *CartItem
	err error
}

// Expect sets up expected params for CartsRepository.GetCartItem
func (mmGetCartItem *mCartsRepositoryMockGetCartItem) Expect(ctx context.Context, user int64, sku uint32) *mCartsRepositoryMockGetCartItem {
	if mmGetCartItem.mock.funcGetCartItem != nil {
		mmGetCartItem.mock.t.Fatalf("CartsRepositoryMock.GetCartItem mock is already set by Set")
	}

	if mmGetCartItem.defaultExpectation == nil {
		mmGetCartItem.defaultExpectation = &CartsRepositoryMockGetCartItemExpectation{}
	}

	mmGetCartItem.defaultExpectation.params = &CartsRepositoryMockGetCartItemParams{ctx, user, sku}
	for _, e := range mmGetCartItem.expectations {
		if minimock.Equal(e.params, mmGetCartItem.defaultExpectation.params) {
			mmGetCartItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCartItem.defaultExpectation.params)
		}
	}

	return mmGetCartItem
}

// Inspect accepts an inspector function that has same arguments as the CartsRepository.GetCartItem
func (mmGetCartItem *mCartsRepositoryMockGetCartItem) Inspect(f func(ctx context.Context, user int64, sku uint32)) *mCartsRepositoryMockGetCartItem {
	if mmGetCartItem.mock.inspectFuncGetCartItem != nil {
		mmGetCartItem.mock.t.Fatalf("Inspect function is already set for CartsRepositoryMock.GetCartItem")
	}

	mmGetCartItem.mock.inspectFuncGetCartItem = f

	return mmGetCartItem
}

// Return sets up results that will be returned by CartsRepository.GetCartItem
func (mmGetCartItem *mCartsRepositoryMockGetCartItem) Return(cp1 *CartItem, err error) *CartsRepositoryMock {
	if mmGetCartItem.mock.funcGetCartItem != nil {
		mmGetCartItem.mock.t.Fatalf("CartsRepositoryMock.GetCartItem mock is already set by Set")
	}

	if mmGetCartItem.defaultExpectation == nil {
		mmGetCartItem.defaultExpectation = &CartsRepositoryMockGetCartItemExpectation{mock: mmGetCartItem.mock}
	}
	mmGetCartItem.defaultExpectation.results = &CartsRepositoryMockGetCartItemResults{cp1, err}
	return mmGetCartItem.mock
}

// Set uses given function f to mock the CartsRepository.GetCartItem method
func (mmGetCartItem *mCartsRepositoryMockGetCartItem) Set(f func(ctx context.Context, user int64, sku uint32) (cp1 *CartItem, err error)) *CartsRepositoryMock {
	if mmGetCartItem.defaultExpectation != nil {
		mmGetCartItem.mock.t.Fatalf("Default expectation is already set for the CartsRepository.GetCartItem method")
	}

	if len(mmGetCartItem.expectations) > 0 {
		mmGetCartItem.mock.t.Fatalf("Some expectations are already set for the CartsRepository.GetCartItem method")
	}

	mmGetCartItem.mock.funcGetCartItem = f
	return mmGetCartItem.mock
}

// When sets expectation for the CartsRepository.GetCartItem which will trigger the result defined by the following
// Then helper
func (mmGetCartItem *mCartsRepositoryMockGetCartItem) When(ctx context.Context, user int64, sku uint32) *CartsRepositoryMockGetCartItemExpectation {
	if mmGetCartItem.mock.funcGetCartItem != nil {
		mmGetCartItem.mock.t.Fatalf("CartsRepositoryMock.GetCartItem mock is already set by Set")
	}

	expectation := &CartsRepositoryMockGetCartItemExpectation{
		mock:   mmGetCartItem.mock,
		params: &CartsRepositoryMockGetCartItemParams{ctx, user, sku},
	}
	mmGetCartItem.expectations = append(mmGetCartItem.expectations, expectation)
	return expectation
}

// Then sets up CartsRepository.GetCartItem return parameters for the expectation previously defined by the When method
func (e *CartsRepositoryMockGetCartItemExpectation) Then(cp1 *CartItem, err error) *CartsRepositoryMock {
	e.results = &CartsRepositoryMockGetCartItemResults{cp1, err}
	return e.mock
}

// GetCartItem implements CartsRepository
func (mmGetCartItem *CartsRepositoryMock) GetCartItem(ctx context.Context, user int64, sku uint32) (cp1 *CartItem, err error) {
	mm_atomic.AddUint64(&mmGetCartItem.beforeGetCartItemCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCartItem.afterGetCartItemCounter, 1)

	if mmGetCartItem.inspectFuncGetCartItem != nil {
		mmGetCartItem.inspectFuncGetCartItem(ctx, user, sku)
	}

	mm_params := &CartsRepositoryMockGetCartItemParams{ctx, user, sku}

	// Record call args
	mmGetCartItem.GetCartItemMock.mutex.Lock()
	mmGetCartItem.GetCartItemMock.callArgs = append(mmGetCartItem.GetCartItemMock.callArgs, mm_params)
	mmGetCartItem.GetCartItemMock.mutex.Unlock()

	for _, e := range mmGetCartItem.GetCartItemMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetCartItem.GetCartItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCartItem.GetCartItemMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCartItem.GetCartItemMock.defaultExpectation.params
		mm_got := CartsRepositoryMockGetCartItemParams{ctx, user, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCartItem.t.Errorf("CartsRepositoryMock.GetCartItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCartItem.GetCartItemMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCartItem.t.Fatal("No results are set for the CartsRepositoryMock.GetCartItem")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetCartItem.funcGetCartItem != nil {
		return mmGetCartItem.funcGetCartItem(ctx, user, sku)
	}
	mmGetCartItem.t.Fatalf("Unexpected call to CartsRepositoryMock.GetCartItem. %v %v %v", ctx, user, sku)
	return
}

// GetCartItemAfterCounter returns a count of finished CartsRepositoryMock.GetCartItem invocations
func (mmGetCartItem *CartsRepositoryMock) GetCartItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartItem.afterGetCartItemCounter)
}

// GetCartItemBeforeCounter returns a count of CartsRepositoryMock.GetCartItem invocations
func (mmGetCartItem *CartsRepositoryMock) GetCartItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartItem.beforeGetCartItemCounter)
}

// Calls returns a list of arguments used in each call to CartsRepositoryMock.GetCartItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCartItem *mCartsRepositoryMockGetCartItem) Calls() []*CartsRepositoryMockGetCartItemParams {
	mmGetCartItem.mutex.RLock()

	argCopy := make([]*CartsRepositoryMockGetCartItemParams, len(mmGetCartItem.callArgs))
	copy(argCopy, mmGetCartItem.callArgs)

	mmGetCartItem.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartItemDone returns true if the count of the GetCartItem invocations corresponds
// the number of defined expectations
func (m *CartsRepositoryMock) MinimockGetCartItemDone() bool {
	for _, e := range m.GetCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartItemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartItem != nil && mm_atomic.LoadUint64(&m.afterGetCartItemCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCartItemInspect logs each unmet expectation
func (m *CartsRepositoryMock) MinimockGetCartItemInspect() {
	for _, e := range m.GetCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartsRepositoryMock.GetCartItem with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartItemCounter) < 1 {
		if m.GetCartItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartsRepositoryMock.GetCartItem")
		} else {
			m.t.Errorf("Expected call to CartsRepositoryMock.GetCartItem with params: %#v", *m.GetCartItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartItem != nil && mm_atomic.LoadUint64(&m.afterGetCartItemCounter) < 1 {
		m.t.Error("Expected call to CartsRepositoryMock.GetCartItem")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartsRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddToCartInspect()

		m.MinimockDeleteCartInspect()

		m.MinimockDeleteFromCartInspect()

		m.MinimockGetCartInspect()

		m.MinimockGetCartItemInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartsRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartsRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddToCartDone() &&
		m.MinimockDeleteCartDone() &&
		m.MinimockDeleteFromCartDone() &&
		m.MinimockGetCartDone() &&
		m.MinimockGetCartItemDone()
}
